import { extend, Internationalization, isNullOrUndefined } from '@syncfusion/ej2-base';
import { PivotUtil } from './util';
/**
 * PivotEngine is used to manipulate the relational or Multi-Dimensional data as pivoting values.
 */
/** @hidden */
var PivotEngine = /** @class */ (function () {
    /**
     * Constructor for PivotEngine class
     * @param  {DataOptions} dataSource?
     * @param  {string} mode?
     * @hidden
     */
    /* tslint:disable:align */
    function PivotEngine(dataSource, mode, savedFieldList, pageSettings, enableValueSoring, isDrillThrough) {
        /** @hidden */
        this.formatFields = {};
        /** @hidden */
        this.calculatedFields = {};
        /** @hidden */
        this.calculatedFormulas = {};
        /** @hidden */
        this.valueAxis = 0;
        /** @hidden */
        this.saveDataHeaders = {};
        /** @hidden */
        this.columnCount = 0;
        /** @hidden */
        this.rowCount = 0;
        /** @hidden */
        this.colFirstLvl = 0;
        /** @hidden */
        this.rowFirstLvl = 0;
        /** @hidden */
        this.rowStartPos = 0;
        /** @hidden */
        this.colStartPos = 0;
        /** @hidden */
        this.enableValueSorting = false;
        /** @hidden */
        this.headerCollection = { rowHeaders: [], columnHeaders: [], rowHeadersCount: 0, columnHeadersCount: 0 };
        this.valueMatrix = [];
        this.indexMatrix = [];
        this.rMembers = [];
        this.cMembers = [];
        this.memberCnt = -1;
        this.pageInLimit = false;
        this.endPos = 0;
        this.removeCount = 0;
        this.colHdrBufferCalculated = false;
        this.colValuesLength = 1;
        this.rowValuesLength = 1;
        this.slicedHeaders = [];
        this.fieldFilterMem = {};
        this.filterPosObj = {};
        this.selectedHeaders = { selectedHeader: [], values: [] };
        this.rawIndexObject = {};
        this.isEditing = false;
        /* tslint:enable:align */
        var fields;
        var val;
        var filterRw;
        this.globalize = new Internationalization();
        this.enableSort = dataSource.enableSorting;
        this.showSubTotals = isNullOrUndefined(dataSource.showSubTotals) ? true : dataSource.showSubTotals;
        this.showRowSubTotals = isNullOrUndefined(dataSource.showRowSubTotals) ? true : dataSource.showRowSubTotals;
        this.showColumnSubTotals = isNullOrUndefined(dataSource.showColumnSubTotals) ? true : dataSource.showColumnSubTotals;
        this.showGrandTotals = isNullOrUndefined(dataSource.showGrandTotals) ? true : dataSource.showGrandTotals;
        this.showRowGrandTotals = isNullOrUndefined(dataSource.showRowGrandTotals) ? true : dataSource.showRowGrandTotals;
        this.showColumnGrandTotals = isNullOrUndefined(dataSource.showColumnGrandTotals) ? true : dataSource.showColumnGrandTotals;
        this.allowValueFilter = dataSource.allowValueFilter;
        this.isValueFilterEnabled = false;
        this.enableValueSorting = enableValueSoring;
        fields = dataSource.data[0];
        this.fields = Object.keys(fields);
        this.rows = dataSource.rows ? dataSource.rows : [];
        this.columns = dataSource.columns ? dataSource.columns : [];
        this.filters = dataSource.filters ? dataSource.filters : [];
        this.formats = dataSource.formatSettings ? dataSource.formatSettings : [];
        this.values = dataSource.values ? dataSource.values : [];
        this.calculatedFieldSettings = dataSource.calculatedFieldSettings ? dataSource.calculatedFieldSettings : [];
        this.enableSort = dataSource.enableSorting === undefined ? true : dataSource.enableSorting;
        this.validateFilters(dataSource);
        this.isExpandAll = (this.isValueFiltersAvail && dataSource.allowValueFilter) ? true : dataSource.expandAll;
        this.drilledMembers =
            dataSource.drilledMembers ? (this.isValueFiltersAvail && dataSource.allowValueFilter) ? [] : dataSource.drilledMembers : [];
        this.isMutiMeasures = this.values.length > 1 ? true : false;
        this.valueAxis = dataSource.valueAxis === 'row' ? 1 : 0;
        this.rowValuesLength = this.valueAxis === 1 ? this.values.length : 1;
        this.colValuesLength = this.valueAxis === 0 ? this.values.length : 1;
        this.valueSortSettings = dataSource.valueSortSettings ||
            { sortOrder: 'None', headerDelimiter: '.', headerText: '', columnIndex: undefined };
        this.valueSortData = [];
        this.pageSettings = pageSettings ? pageSettings : this.pageSettings;
        this.savedFieldList = savedFieldList;
        this.isDrillThrough = isDrillThrough ? isDrillThrough : false;
        this.getFieldList(fields, this.enableSort, dataSource.allowValueFilter);
        this.fillFieldMembers(dataSource.data, this.indexMatrix);
        this.updateSortSettings(dataSource.sortSettings, this.enableSort);
        this.valueMatrix = this.generateValueMatrix(dataSource.data);
        this.filterMembers = [];
        this.updateFilterMembers(dataSource);
        this.generateGridData(dataSource);
        return this;
    }
    PivotEngine.prototype.getFormattedFields = function (fields) {
        var cnt = this.formats.length;
        while (cnt--) {
            this.formatFields[this.formats[cnt].name] = this.formats[cnt];
            // for (let len: number = 0, lnt: number = fields.length; len < lnt; len++) {
            // if (fields[len] && fields[len].name === this.formats[cnt].name) {
            //     this.formatFields[fields[len].name] = this.formats[cnt];
            // }
            // }
        }
    };
    PivotEngine.prototype.getFieldList = function (fields, isSort, isValueFilteringEnabled) {
        var type;
        var keys = this.fields;
        var dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns, this.values, this.filters);
        this.getFormattedFields(dataFields);
        this.getCalculatedField(keys);
        var len = keys.length;
        if (this.savedFieldList) {
            this.fieldList = this.savedFieldList;
            while (len--) { /** while is used for better performance than for */
                var key = keys[len];
                if (this.fieldList[key]) {
                    this.fieldList[key].isSelected = false;
                    this.fieldList[key].index = len;
                    this.fieldList[key].filter = [];
                    this.fieldList[key].isExcelFilter = false;
                    this.fieldList[key].filterType = '';
                    if (this.isValueFiltersAvail && isValueFilteringEnabled) {
                        this.fieldList[key].dateMember = [];
                        this.fieldList[key].formattedMembers = {};
                        this.fieldList[key].members = {};
                    }
                }
                else {
                    this.fieldList[key] = {
                        id: key,
                        caption: key,
                        type: (type === undefined || type === 'undefined') ? 'number' : type,
                        filterType: '',
                        index: len,
                        filter: [],
                        sort: isSort ? 'Ascending' : 'None',
                        isSelected: false
                    };
                }
            }
        }
        else {
            while (len--) { /** while is used for better performance than for */
                var key = keys[len];
                type = PivotUtil.getType(fields[key]);
                if (!this.fieldList) {
                    this.fieldList = {};
                }
                this.fieldList[key] = {
                    id: key,
                    caption: key,
                    type: (type === undefined || type === 'undefined') ? 'number' : type,
                    filterType: '',
                    index: len,
                    filter: [],
                    sort: isSort ? 'Ascending' : 'None',
                    isSelected: false
                };
            }
        }
        this.updateTreeViewData(dataFields);
    };
    PivotEngine.prototype.updateFieldList = function (savedFieldList) {
        var keys = this.fields;
        var len = keys.length;
        while (len--) { /** while is used for better performance than for */
            this.fieldList[keys[len]].isExcelFilter = savedFieldList[keys[len]].isExcelFilter;
        }
    };
    PivotEngine.prototype.updateTreeViewData = function (fields) {
        var cnt = fields.length;
        var lnt = this.calculatedFieldSettings.length;
        while (cnt--) {
            if (this.fieldList[fields[cnt].name]) {
                var field = this.fieldList[fields[cnt].name];
                field.caption = fields[cnt].caption ? fields[cnt].caption : fields[cnt].name;
                field.isSelected = true;
                field.showNoDataItems = fields[cnt].showNoDataItems;
                field.aggregateType = fields[cnt].type;
                field.baseField = fields[cnt].baseField;
                field.baseItem = fields[cnt].baseItem;
            }
        }
        while (lnt--) {
            this.fieldList[this.calculatedFieldSettings[lnt].name].aggregateType = 'CalculatedField';
            this.fieldList[this.calculatedFieldSettings[lnt].name].formula = this.calculatedFieldSettings[lnt].formula;
        }
    };
    PivotEngine.prototype.getCalculatedField = function (keys) {
        for (var _i = 0, _a = this.calculatedFieldSettings; _i < _a.length; _i++) {
            var field = _a[_i];
            this.calculatedFields[field.name] = extend({}, field, null, true);
            this.calculatedFields[field.name].actualFormula = field.formula;
        }
        var fieldKeys = Object.keys(this.calculatedFields);
        for (var calc = 0, cnt = fieldKeys.length; calc < cnt; calc++) {
            var field = this.calculatedFields[fieldKeys[calc]];
            var calcProperties = field.properties;
            var actualFormula = (calcProperties ? calcProperties.formula : field.formula).replace(/ +/g, '');
            var formula = actualFormula.replace(/"/g, '');
            field.formula = formula.indexOf('^') > -1 ? this.powerFunction(formula) : formula;
            field.name = calcProperties ? calcProperties.name : field.name;
            keys.push(field.name);
            var formulaType = actualFormula.split('\"');
            for (var len = 0, lmt = formulaType.length; len < lmt; len++) {
                var type = formulaType[len];
                var aggregateValue = type.split(/[ .:;?!~,`"&|()<>{}\[\]\r\n/\\]+/);
                var selectedString = (aggregateValue[0] === 'DistinctCount' ?
                    'DistinctCount' : aggregateValue[0] === 'PopulationStDev' ?
                    'PopulationStDev' : aggregateValue[0] === 'SampleStDev' ? 'SampleStDev' : aggregateValue[0] === 'PopulationVar' ?
                    'PopulationVar' : aggregateValue[0] === 'SampleVar' ? 'SampleVar' : aggregateValue[0]);
                if (['Sum', 'Count', 'Min', 'Max', 'Avg', 'Product', 'DistinctCount',
                    'PopulationStDev', 'SampleStDev', 'PopulationVar', 'SampleVar'].indexOf(selectedString) !== -1) {
                    var index = keys.indexOf(aggregateValue[1]);
                    if (!this.calculatedFormulas[field.name]) {
                        this.calculatedFormulas[field.name] = [{
                                index: index,
                                type: selectedString,
                                formula: type,
                            }];
                    }
                    else {
                        this.calculatedFormulas[field.name].push({
                            index: index,
                            type: selectedString,
                            formula: type,
                        });
                    }
                }
            }
        }
    };
    PivotEngine.prototype.validateFilters = function (data) {
        this.isValueFiltersAvail = false;
        var filterElements = data.filterSettings ? data.filterSettings : [];
        var dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns);
        for (var _i = 0, filterElements_1 = filterElements; _i < filterElements_1.length; _i++) {
            var filter = filterElements_1[_i];
            for (var _a = 0, dataFields_1 = dataFields; _a < dataFields_1.length; _a++) {
                var field = dataFields_1[_a];
                if (filter.name === field.name && filter.type === 'Value') {
                    this.isValueFiltersAvail = true;
                    break;
                }
            }
            if (this.isValueFiltersAvail) {
                break;
            }
        }
    };
    PivotEngine.prototype.fillFieldMembers = function (data, indMat) {
        var keys = this.fields;
        var dlen = data.length;
        var fList = this.fieldList;
        var kLn = keys.length;
        for (var kl = 0; kl < kLn; kl++) {
            var key = keys[kl];
            if (!fList[key].members) {
                fList[key].members = {};
            }
            if (!fList[key].formattedMembers) {
                fList[key].formattedMembers = {};
            }
            if (!fList[key].dateMember) {
                fList[key].dateMember = [];
            }
            var members = fList[key].members;
            var isDataAvail = Object.keys(members).length > 0 ? true : false;
            var formattedMembers = fList[key].formattedMembers;
            var dateMember = fList[key].dateMember;
            var membersCnt = 0;
            var fmembersCnt = 0;
            //let sort: string[] = [];
            for (var dl = 0; dl < dlen; dl++) {
                var mkey = data[dl][key];
                if (!isNullOrUndefined(mkey)) {
                    if (!isDataAvail) {
                        var fKey = mkey;
                        var formattedValue = (this.pageSettings && !(this.formatFields[key] &&
                            (['date', 'dateTime', 'time'].indexOf(this.formatFields[key].type) > -1))) ? ({
                            formattedText: isNullOrUndefined(mkey) ? mkey : mkey.toString(),
                            actualText: mkey
                        }) : this.getFormattedValue(mkey, key);
                        if (formattedValue.formattedText) {
                            fKey = formattedValue.formattedText;
                        }
                        if (!members.hasOwnProperty(mkey)) {
                            membersCnt++;
                            members[mkey] = {
                                index: [dl], ordinal: membersCnt,
                                isDrilled: this.isExpandAll ? true : false
                            };
                            /* tslint:disable-next-line:max-line-length */
                            dateMember.push({ formattedText: formattedValue.formattedText, actualText: (formattedValue.dateText ? formattedValue.dateText : formattedValue.actualText) });
                            //sort.push(mkey);
                        }
                        else {
                            members[mkey].index.push(dl);
                        }
                        if (!formattedMembers.hasOwnProperty(fKey)) {
                            fmembersCnt++;
                            formattedMembers[fKey] = {
                                index: [dl], ordinal: fmembersCnt,
                                isDrilled: this.isExpandAll ? true : false
                            };
                        }
                        else {
                            formattedMembers[fKey].index.push(dl);
                        }
                    }
                    if (!(indMat[dl])) {
                        indMat[dl] = [];
                        indMat[dl][kl] = members[mkey].ordinal;
                    }
                    else {
                        indMat[dl][kl] = members[mkey].ordinal;
                    }
                }
            }
            /*sort = Object.keys(members).sort();
            let sortedMembers: Members = {};
            for (let sln: number = 0, slt: number = sort.length; sln < slt; sln++) {
                sortedMembers[sort[sln]] = members[sort[sln]];
            }
            fList[key].members = sortedMembers; */
        }
        this.fillDrilledInfo();
    };
    PivotEngine.prototype.fillDrilledInfo = function () {
        for (var key = 0; key < this.drilledMembers.length; key++) {
            var fieldName = this.drilledMembers[key].name;
            for (var mem = 0; mem < this.drilledMembers[key].items.length; mem++) {
                var memberName = this.drilledMembers[key].items[mem];
                var field = this.fieldList[fieldName];
                if (field && field.members[memberName]) {
                    field.members[memberName].isDrilled = this.isExpandAll ? false : true;
                }
            }
        }
    };
    PivotEngine.prototype.generateValueMatrix = function (data) {
        var keys = this.fields;
        var len = data.length;
        var vMat = [];
        var keyLen = keys.length;
        var flList = this.fieldList;
        while (len--) {
            var record = data[len];
            var tkln = keyLen;
            //if (isNullOrUndefined(vMat[len])) {
            vMat[len] = [];
            //}
            while (tkln--) {
                var key = keys[tkln];
                vMat[len][tkln] = (flList[key].type === 'number') ? data[len][key] : 1;
            }
        }
        return vMat;
    };
    PivotEngine.prototype.updateSortSettings = function (sortSettings, isSort) {
        for (var sln = 0, slt = sortSettings ? sortSettings.length : 0; sln < slt && isSort; sln++) {
            this.fieldList[sortSettings[sln].name].sort = sortSettings[sln].order;
        }
    };
    PivotEngine.prototype.updateFilterMembers = function (source) {
        var filterRw = this.filterMembers;
        var list = {};
        //let eList: {[key: string] : number} = {};
        var isInclude = this.getFilters(source, list);
        //this.getFilterExcludeList(source.rows, flist);
        //this.getFilterExcludeList(source.columns, flist);
        //this.getFilterExcludeList(source.filters, flist);
        // let filters: Iterator = isInclude ? iList : eList;
        var dln = this.indexMatrix.length;
        if (isInclude) {
            var keys = list.include.index;
            for (var ln = 0; ln < keys.length; ln++) {
                if (list.exclude === undefined || list.exclude.indexObject[keys[ln]] === undefined) {
                    filterRw.push(keys[ln]);
                }
            }
        }
        else {
            for (var ln = 0; ln < dln; ln++) {
                if (list.exclude === undefined || list.exclude.indexObject[ln] === undefined) {
                    filterRw.push(ln);
                }
            }
        }
    };
    PivotEngine.prototype.getFilters = function (source, ilist) {
        var filterElements = source.filterSettings ? source.filterSettings : [];
        var filters = this.filters;
        var isInclude = false;
        var filter = [];
        //let type: string;
        for (var rln = 0, rlt = filterElements.length; rln < rlt; rln++) {
            var filterElement = filterElements[rln].properties ?
                filterElements[rln].properties : filterElements[rln];
            if (this.fieldList[filterElement.name].isSelected && this.isValidFilterField(filterElement, source.allowLabelFilter)) {
                this.applyLabelFilter(filterElement);
                filter = filterElement ? filterElement.items : [];
                if (filterElement.type && filterElement.type === 'Include') {
                    /* tslint:disable-next-line:max-line-length */
                    this.frameFilterList(filter, filterElement.name, ilist, 'include', filterElement.showLabelFilter, isInclude);
                    isInclude = true;
                }
                else {
                    this.frameFilterList(filter, filterElement.name, ilist, 'exclude', filterElement.showLabelFilter);
                }
                if (filterElement.showLabelFilter) {
                    filterElement.items = [];
                    filterElement.type = filterElement.showDateFilter ? 'Date' : filterElement.showNumberFilter ? 'Number' : 'Label';
                }
            }
        }
        /* for (let cln: number = 0, clt: number = cols.length; cln < clt; cln ++) {
             filter = cols[cln].filter ? cols[cln].filter.items : [];
             if (filter.length && cols[cln].filter.type && cols[cln].filter.type === 'include') {
                 //type = cols[cln].filter.type;
                 this.frameFilterList(filter, cols[cln].name, ilist, 'include', isInclude);
                 isInclude = true;
             } else {
                 this.frameFilterList(filter, cols[cln].name, ilist, 'exclude');
             }
         }
         for (let vln: number = 0, vlt: number = filters.length; vln < vlt; vln ++) {
             filter = filters[vln].filter ? filters[vln].filter.items : [];
             if (filter.length && filters[vln].filter.type && filters[vln].filter.type === 'include') {
                 this.frameFilterList(filter, filters[vln].name, ilist, 'include', isInclude);
                 isInclude = true;
             } else {
                 this.frameFilterList(filter, filters[vln].name, ilist, 'exclude');
             }
         } */
        return isInclude;
    };
    PivotEngine.prototype.isValidFilterField = function (filterElement, allowLabelFiltering) {
        var isValidFilterElement = false;
        var filterTypes = ['Include', 'Exclude'];
        var dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns);
        if (this.fieldList[filterElement.name].isSelected && filterTypes.indexOf(filterElement.type) >= 0) {
            var isNotValidFilterElement = false;
            for (var _i = 0, _a = this.values; _i < _a.length; _i++) {
                var field = _a[_i];
                if (filterElement.name === field.name) {
                    isNotValidFilterElement = true;
                    break;
                }
            }
            if (!isNotValidFilterElement) {
                isValidFilterElement = true;
            }
        }
        else {
            for (var _b = 0, dataFields_2 = dataFields; _b < dataFields_2.length; _b++) {
                var field = dataFields_2[_b];
                if (filterElement.name === field.name && allowLabelFiltering &&
                    (['Label', 'Date', 'Number'].indexOf(filterElement.type) >= 0)) {
                    isValidFilterElement = true;
                    break;
                }
            }
        }
        return isValidFilterElement;
    };
    PivotEngine.prototype.applyLabelFilter = function (filterElement) {
        if (['Label', 'Date', 'Number'].indexOf(filterElement.type) >= 0) {
            var members = Object.keys(this.fieldList[filterElement.name].members);
            filterElement.showLabelFilter = true;
            if (filterElement.type === 'Label') {
                /* tslint:disable-next-line:max-line-length */
                filterElement.items = this.getLabelFilterMembers(members, filterElement.condition, filterElement.value1, filterElement.value2);
            }
            else if (filterElement.type === 'Date') {
                filterElement.showDateFilter = true;
                /* tslint:disable-next-line:max-line-length */
                filterElement.items = this.getDateFilterMembers(members, filterElement.name, filterElement.condition, filterElement.value1, filterElement.value2);
            }
            else {
                filterElement.showNumberFilter = true;
                filterElement.items = [];
                for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {
                    var member = members_1[_i];
                    var operand1 = this.getParsedValue(filterElement.name, filterElement.value1);
                    var operand2 = this.getParsedValue(filterElement.name, filterElement.value2);
                    var cValue = this.getParsedValue(filterElement.name, member);
                    /* tslint:disable-next-line:max-line-length */
                    if (this.validateFilterValue(cValue, filterElement.condition, operand1, operand2)) {
                        filterElement.items.push(member);
                    }
                }
            }
            var excludeOperators = ['DoesNotBeginWith', 'DoesNotContains', 'DoesNotEndsWith', 'DoesNotEquals', 'NotBetween'];
            filterElement.type = (excludeOperators.indexOf(filterElement.condition) > -1 &&
                !filterElement.showNumberFilter) ? 'Exclude' : 'Include';
        }
        else {
            filterElement.showLabelFilter = false;
        }
    };
    PivotEngine.prototype.getLabelFilterMembers = function (members, operator, value1, value2) {
        var items = [];
        for (var _i = 0, members_2 = members; _i < members_2.length; _i++) {
            var member = members_2[_i];
            var filterValue = member.toLowerCase();
            if (value1.toString()) {
                switch (operator) {
                    case 'Equals':
                    case 'DoesNotEquals':
                        if (filterValue === value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'BeginWith':
                    case 'DoesNotBeginWith':
                        if (filterValue.indexOf(value1.toLowerCase()) === 0) {
                            items.push(member);
                        }
                        break;
                    case 'EndsWith':
                    case 'DoesNotEndsWith':
                        if (filterValue.match(value1.toLowerCase() + '$') != null) {
                            items.push(member);
                        }
                        break;
                    case 'Contains':
                    case 'DoesNotContains':
                        if (filterValue.indexOf(value1.toLowerCase()) > -1) {
                            items.push(member);
                        }
                        break;
                    case 'GreaterThan':
                        if (filterValue > value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'GreaterThanOrEqualTo':
                        if (filterValue >= value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'LessThan':
                        if (filterValue < value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'LessThanOrEqualTo':
                        if (filterValue <= value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'Between':
                    case 'NotBetween':
                        if ((filterValue >= value1.toLowerCase()) && (filterValue <= value2.toLowerCase())) {
                            items.push(member);
                        }
                        break;
                }
            }
        }
        return items;
    };
    PivotEngine.prototype.getDateFilterMembers = function (members, name, operator, value1, value2) {
        var items = [];
        for (var _i = 0, members_3 = members; _i < members_3.length; _i++) {
            var member = members_3[_i];
            var filterValue = new Date(member);
            if (value1) {
                switch (operator) {
                    case 'Equals':
                    case 'DoesNotEquals':
                        if ((PivotUtil.resetTime(filterValue)).getTime() === (PivotUtil.resetTime(value1)).getTime()) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'After':
                        if ((PivotUtil.resetTime(filterValue)).getTime() > (PivotUtil.resetTime(value1)).getTime()) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'AfterOrEqualTo':
                        if ((PivotUtil.resetTime(filterValue)).getTime() >= (PivotUtil.resetTime(value1)).getTime()) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'Before':
                        if ((PivotUtil.resetTime(filterValue)).getTime() < (PivotUtil.resetTime(value1)).getTime()) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'BeforeOrEqualTo':
                        if ((PivotUtil.resetTime(filterValue)).getTime() <= (PivotUtil.resetTime(value1)).getTime()) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'Between':
                    case 'NotBetween':
                        if (((PivotUtil.resetTime(filterValue)).getTime() >= (PivotUtil.resetTime(value1)).getTime()) &&
                            ((PivotUtil.resetTime(filterValue)).getTime() <= (PivotUtil.resetTime(value2)).getTime())) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                }
            }
        }
        return items;
    };
    PivotEngine.prototype.validateFilterValue = function (val, operator, value1, value2) {
        var isMemberInclude = false;
        if (typeof (value1) === 'number') {
            switch (operator) {
                case 'Equals':
                    if (val === value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'DoesNotEquals':
                    if (val !== value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'GreaterThan':
                    if (val > value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'GreaterThanOrEqualTo':
                    if (val >= value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'LessThan':
                    if (val < value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'LessThanOrEqualTo':
                    if (val <= value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'Between':
                    if ((val >= value1) && (val <= value2)) {
                        isMemberInclude = true;
                    }
                    break;
                case 'NotBetween':
                    if (!((val >= value1) && (val <= value2))) {
                        isMemberInclude = true;
                    }
                    break;
            }
        }
        return isMemberInclude;
    };
    /* tslint:disable-next-line:max-line-length */
    PivotEngine.prototype.frameFilterList = function (filter, name, list, type, isLabelFilter, isInclude) {
        var _this = this;
        var updateFilter = function () {
            var fln = 0;
            var field = _this.fieldList[name];
            field.filter = filter;
            field.filterType = type;
            field.isExcelFilter = isLabelFilter;
            var members = (_this.formatFields[name] &&
                (['date', 'dateTime', 'time'].indexOf(_this.formatFields[name].type) > -1)) ?
                field.formattedMembers : field.members;
            var allowFil = isInclude;
            var final = {};
            var filterObj = {};
            final[type] = { indexObject: {}, index: [] };
            _this.fieldFilterMem[name] = { memberObj: {} };
            while (filter[fln]) {
                var indx = members[filter[fln]].index;
                if (type === 'include') {
                    for (var iln = 0, ilt = indx.length; iln < ilt; iln++) {
                        if (!allowFil || list[type].indexObject[indx[iln]] !== undefined) {
                            final[type].indexObject[indx[iln]] = indx[iln];
                            final[type].index.push(indx[iln]);
                        }
                    }
                }
                else {
                    for (var iln = 0, ilt = indx.length; iln < ilt; iln++) {
                        if (list[type].indexObject[indx[iln]] === undefined) {
                            list[type].indexObject[indx[iln]] = indx[iln];
                            list[type].index.push(indx[iln]);
                        }
                    }
                    _this.fieldFilterMem[name].memberObj[filter[fln]] = filter[fln];
                }
                fln++;
            }
            if (type === 'include') {
                list[type] = final[type];
                for (var iln = 0; iln < filter.length; iln++) {
                    filterObj[filter[iln]] = filter[iln];
                }
                var items = Object.keys(members);
                for (var iln = 0, ilt = items.length; iln < ilt; iln++) {
                    if (filterObj[items[iln]] === undefined) {
                        _this.fieldFilterMem[name].memberObj[items[iln]] = items[iln];
                    }
                }
            }
        };
        if (!list[type]) {
            list[type] = { indexObject: {}, index: [] };
            updateFilter();
        }
        else {
            updateFilter();
        }
        // }
    };
    /* tslint:disable-next-line:max-line-length */
    PivotEngine.prototype.applyValueFiltering = function (rowData, level, rows, columns, valueFilter, rowFilterData, type) {
        this.isValueFiltered = false;
        var allMember = extend({}, rows[rows.length - 1], null, true);
        this.getFilteredData(rows, columns, valueFilter, rowFilterData, level, rowData.name, allMember, type);
        if (this.isValueFiltered) {
            rowFilterData.push(allMember);
            rows = rowFilterData;
        }
        return rows;
    };
    /* tslint:disable-next-line:max-line-length */
    PivotEngine.prototype.getFilteredData = function (rows, columns, filterSettings, rowFilterData, level, fieldName, allMember, type) {
        var rLen = rows.length;
        for (var i = 0; i < rLen; i++) {
            if (filterSettings[fieldName]) {
                if (rows[i].level === level) {
                    this.isValueFiltered = true;
                    this.fieldList[fieldName].isExcelFilter = true;
                    var value = 0;
                    var measure = filterSettings[fieldName].measure;
                    var mPos = this.fieldList[measure].index;
                    var aggregate = this.fieldList[measure].aggregateType;
                    value = (type === 'row' ? this.getAggregateValue(rows[i].index, columns.indexObject, mPos, aggregate) :
                        this.getAggregateValue(columns.index, rows[i].indexObject, mPos, aggregate));
                    var operand1 = this.getParsedValue(measure, filterSettings[fieldName].value1);
                    var operand2 = this.getParsedValue(measure, filterSettings[fieldName].value2);
                    /* tslint:disable-next-line:max-line-length */
                    if (!this.validateFilterValue(value, filterSettings[fieldName].condition, operand1, operand2) && rows[i].type !== 'grand sum') {
                        var data = this.removefilteredData(rows[i], this.valueFilteredData);
                        var row = data ? data : rows[i];
                        this.validateFilteredParentData(row, this.valueFilteredData, allMember, 0, level, type);
                    }
                    else if (rows[i].type !== 'grand sum') {
                        rowFilterData.push(extend({}, rows[i], null, true));
                        rowFilterData[rowFilterData.length - 1].isLevelFiltered = true;
                    }
                }
                else if (rows[i].hasChild && rows[i].members.length > 0 && rows[i].type !== 'grand sum') {
                    rowFilterData.push(extend({}, rows[i], null, true));
                    rowFilterData[rowFilterData.length - 1].members = [];
                    rowFilterData[rowFilterData.length - 1].isLevelFiltered = true;
                    /* tslint:disable-next-line:max-line-length */
                    this.getFilteredData(rows[i].members, columns, filterSettings, rowFilterData[rowFilterData.length - 1].members, level, fieldName, allMember, type);
                }
            }
        }
    };
    PivotEngine.prototype.getParsedValue = function (measure, value) {
        var cValue = value ? value.toString() : '';
        if (this.formatFields[measure] && value) {
            var formatSetting = extend({}, this.formatFields[measure], null, true);
            delete formatSetting.name;
            return this.globalize.parseNumber(cValue, formatSetting);
        }
        else {
            return this.globalize.parseNumber(cValue, { format: 'N' });
        }
    };
    PivotEngine.prototype.removefilteredData = function (row, rowFilterData) {
        var rows = extend([], rowFilterData, null, true);
        var filteredData;
        for (var i = 0; i < rows.length; i++) {
            if (row.isLevelFiltered && row.axis === rows[i].axis &&
                row.valueSort.levelName === rows[i].valueSort.levelName &&
                row.actualText === rows[i].actualText && row.axis === rows[i].axis &&
                row.level === rows[i].level && row.ordinal === rows[i].ordinal) {
                filteredData = rows[i];
                rowFilterData.splice(i, 1);
                break;
            }
            else if (rowFilterData[i].hasChild && rowFilterData[i].members.length > 0) {
                this.removefilteredData(row, rowFilterData[i].members);
            }
        }
        return filteredData;
    };
    /* tslint:disable-next-line:max-line-length */
    PivotEngine.prototype.validateFilteredParentData = function (row, rows, allMemberData, i, level, type) {
        if (rows.length > 0) {
            for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {
                var rowFilteredData = rows_1[_i];
                if (rowFilteredData.level === i) {
                    if (type === 'row') {
                        var index = row.index;
                        for (var _a = 0, index_1 = index; _a < index_1.length; _a++) {
                            var key = index_1[_a];
                            if (allMemberData.index.indexOf(key) >= 0) {
                                allMemberData.index.splice(allMemberData.index.indexOf(key), 1);
                            }
                            if (((row.valueSort.levelName.toString()).indexOf(rowFilteredData.valueSort.levelName.toString()) >= 0) &&
                                rowFilteredData.level !== level && rowFilteredData.index.indexOf(key) >= 0) {
                                rowFilteredData.index.splice(rowFilteredData.index.indexOf(key), 1);
                            }
                        }
                    }
                    else {
                        var index = row.indexObject;
                        for (var _b = 0, _c = Object.keys(index); _b < _c.length; _b++) {
                            var key = _c[_b];
                            if (index.hasOwnProperty(key)) {
                                delete allMemberData.indexObject[key];
                                if (((row.valueSort.levelName.toString()).indexOf(rowFilteredData.valueSort.levelName.toString()) >= 0) &&
                                    rowFilteredData.level !== level) {
                                    delete rowFilteredData.indexObject[key];
                                }
                            }
                        }
                    }
                    if (rowFilteredData && rowFilteredData.members.length > 0 &&
                        rowFilteredData.members[0].level === i + 1 && rowFilteredData.members[0].level !== level) {
                        this.validateFilteredParentData(row, rowFilteredData.members, allMemberData, i + 1, level, type);
                    }
                }
            }
        }
        else {
            if (type === 'row') {
                var index = row.index;
                for (var _d = 0, index_2 = index; _d < index_2.length; _d++) {
                    var key = index_2[_d];
                    if (allMemberData.index.indexOf(key) >= 0) {
                        allMemberData.index.splice(allMemberData.index.indexOf(key), 1);
                    }
                }
            }
            else {
                var index = row.indexObject;
                for (var _e = 0, _f = Object.keys(index); _e < _f.length; _e++) {
                    var key = _f[_e];
                    if (index.hasOwnProperty(key)) {
                        delete allMemberData.indexObject[key];
                    }
                }
            }
        }
    };
    /* tslint:disable-next-line:max-line-length */
    PivotEngine.prototype.updateFramedHeaders = function (framedHeaders, dataHeaders, filteredHeaders, headers, type) {
        for (var _i = 0, framedHeaders_1 = framedHeaders; _i < framedHeaders_1.length; _i++) {
            var dHeader = framedHeaders_1[_i];
            this.isHeaderAvail = false;
            if (this.validateFilteredHeaders(dHeader, filteredHeaders, type) || dHeader.type === 'grand sum') {
                if (type === 'row') {
                    this.rowCount += this.rowValuesLength;
                }
                else {
                    this.columnCount += this.colValuesLength;
                }
                headers.push(extend({}, dHeader, null, true));
                headers[headers.length - 1].members = [];
                if (dHeader.hasChild && dHeader.isDrilled && dHeader.members.length > 0) {
                    this.updateFramedHeaders(dHeader.members, dataHeaders, filteredHeaders, headers[headers.length - 1].members, type);
                }
            }
        }
        return this.filterFramedHeaders;
    };
    PivotEngine.prototype.validateFilteredHeaders = function (dHeader, filteredHeaders, type) {
        for (var _i = 0, filteredHeaders_1 = filteredHeaders; _i < filteredHeaders_1.length; _i++) {
            var vHeader = filteredHeaders_1[_i];
            if (!this.isHeaderAvail) {
                if (dHeader.actualText === vHeader.actualText &&
                    dHeader.level === vHeader.level &&
                    dHeader.valueSort.levelName === vHeader.valueSort.levelName) {
                    if (type === 'row') {
                        if (vHeader.index.length > 0) {
                            this.isHeaderAvail = true;
                            dHeader.index = vHeader.index;
                            return true;
                        }
                        else {
                            this.isHeaderAvail = false;
                            dHeader.index = vHeader.index;
                            return false;
                        }
                    }
                    else {
                        if (Object.keys(vHeader.indexObject).length > 0) {
                            this.isHeaderAvail = true;
                            dHeader.indexObject = vHeader.indexObject;
                            return true;
                        }
                        else {
                            this.isHeaderAvail = false;
                            dHeader.indexObject = vHeader.indexObject;
                            return false;
                        }
                    }
                }
                else if (vHeader.hasChild && vHeader.members.length > 0 && vHeader.type !== 'grand sum') {
                    this.validateFilteredHeaders(dHeader, vHeader.members, type);
                }
            }
        }
        return this.isHeaderAvail;
    };
    PivotEngine.prototype.isEmptyDataAvail = function (rowHeaders, columnHeaders) {
        this.isEmptyData = false;
        if (rowHeaders.length > 0 && rowHeaders[rowHeaders.length - 1].type === 'grand sum' &&
            rowHeaders[rowHeaders.length - 1].index.length === 0) {
            this.isEmptyData = true;
        }
        if (columnHeaders.length > 0 && columnHeaders[columnHeaders.length - 1].type === 'grand sum' &&
            Object.keys(columnHeaders[columnHeaders.length - 1].indexObject).length === 0) {
            this.isEmptyData = true;
        }
    };
    /** @hidden */
    PivotEngine.prototype.updateGridData = function (dataSource) {
        this.indexMatrix = [];
        for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {
            var field = _a[_i];
            this.fieldList[field].members = {};
            this.fieldList[field].formattedMembers = {};
            this.fieldList[field].dateMember = [];
        }
        this.fillFieldMembers(dataSource.data, this.indexMatrix);
        this.valueMatrix = this.generateValueMatrix(dataSource.data);
        this.filterMembers = [];
        this.cMembers = [];
        this.rMembers = [];
        this.updateFilterMembers(dataSource);
        this.isEditing = true;
        this.isDrillThrough = true;
        this.generateGridData(dataSource);
        this.isEditing = false;
    };
    /* tslint:disable */
    PivotEngine.prototype.generateGridData = function (dataSource, headerCollection) {
        var keys = this.fields;
        var columns = dataSource.columns ? dataSource.columns : [];
        var data = dataSource.data;
        var rows = dataSource.rows ? dataSource.rows : [];
        var filterSettings = dataSource.filterSettings;
        var values = dataSource.values ? dataSource.values : [];
        var size = 1;
        this.removeCount = 0;
        this.isExpandAll = dataSource.expandAll;
        this.drilledMembers = dataSource.drilledMembers ? dataSource.drilledMembers : [];
        this.isEmptyData = false;
        var filterMembers = [];
        var showNoDataItems = (rows[0] && rows[0].showNoDataItems) || (columns[0] && columns[0].showNoDataItems);
        if (showNoDataItems) {
            for (var ln = 0; ln < this.indexMatrix.length; ln++) {
                filterMembers.push(ln);
            }
        }
        for (var ln = 0; ln < this.filterMembers.length; ln++) {
            this.filterPosObj[this.filterMembers[ln]] = this.filterMembers[ln];
        }
        //let childrens: Field = this.fieldList[rows[0].name + ''];
        this.valueSortSettings.columnIndex = undefined;
        var st1 = new Date().getTime();
        if (!this.isValueFilterEnabled || this.isEditing) {
            if (!headerCollection || this.enableValueSorting) {
                this.columnCount = 0;
                this.rowCount = 0;
                this.cMembers = [];
                this.rMembers = [];
                if (rows.length !== 0) {
                    this.rMembers =
                        this.getIndexedHeaders(rows, data, 0, rows[0].showNoDataItems ? filterMembers : this.filterMembers, 'row', '');
                }
                if (columns.length !== 0) {
                    this.cMembers = this.getIndexedHeaders(columns, data, 0, columns[0].showNoDataItems ?
                        filterMembers : this.filterMembers, 'column', '');
                }
                this.insertAllMembersCommon();
            }
            this.saveDataHeaders = (this.isValueFiltersAvail && dataSource.allowValueFilter) ? {
                rowHeaders: extend([], this.rMembers, null, true),
                columnHeaders: extend([], this.cMembers, null, true)
            } : {};
        }
        this.pivotValues = [];
        var gridData = [];
        this.headerContent = [];
        this.valueContent = [];
        this.valueFilteredData = [];
        this.filterFramedHeaders = [];
        var rowheads = [];
        var colheads = [];
        var rowFilteredData = [];
        var columnFilteredData = [];
        var valuesCount = (this.values.length);
        if ((this.isValueFiltersAvail && dataSource.allowValueFilter)) {
            this.valueFilteredData = [];
            var rowHeaders = this.saveDataHeaders.rowHeaders;
            var columnHeaders = this.saveDataHeaders.columnHeaders;
            if (filterSettings.length > 0) {
                var valueFilters = {};
                var valueFields = {};
                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                    var value = values_1[_i];
                    valueFields[value.name] = value;
                }
                for (var _a = 0, filterSettings_1 = filterSettings; _a < filterSettings_1.length; _a++) {
                    var filter = filterSettings_1[_a];
                    rowHeaders = (rowFilteredData.length > 0 ? rowFilteredData : rowHeaders);
                    columnHeaders = (columnFilteredData.length > 0 ? columnFilteredData : columnHeaders);
                    this.valueFilteredData = [];
                    var filterElement = filter.properties ?
                        filter.properties : filter;
                    if (filterElement.type === 'Value' && this.fieldList[filter.name].isSelected) {
                        valueFilters[filter.name] = filter;
                        filterElement.items = [];
                        var isAvail = false;
                        var rLen = rows.length;
                        var cLen = columns.length;
                        for (var i = 0; i < rLen; i++) {
                            if (filterElement.name === rows[i].name && valueFields[filterElement.measure] && !isAvail) {
                                isAvail = true;
                                /* tslint:disable-next-line:max-line-length */
                                rowFilteredData = this.applyValueFiltering(rows[i], i, rowHeaders, columnHeaders[columnHeaders.length - 1], valueFilters, this.valueFilteredData, 'row');
                                break;
                            }
                        }
                        for (var j = 0; j < cLen; j++) {
                            if (filterElement.name === columns[j].name && valueFields[filterElement.measure] && !isAvail) {
                                isAvail = true;
                                /* tslint:disable-next-line:max-line-length */
                                columnFilteredData = this.applyValueFiltering(columns[j], j, columnHeaders, rowHeaders[rowHeaders.length - 1], valueFilters, this.valueFilteredData, 'column');
                                break;
                            }
                        }
                    }
                }
            }
            rowFilteredData = (rowFilteredData.length > 0 ? rowFilteredData : rowHeaders);
            columnFilteredData = (columnFilteredData.length > 0 ? columnFilteredData : columnHeaders);
            this.isEmptyDataAvail(rowFilteredData, columnFilteredData);
            var savedFieldList = extend({}, this.fieldList, null, true);
            this.indexMatrix = [];
            var fields = dataSource.data[0];
            this.getFieldList(fields, this.enableSort, dataSource.allowValueFilter);
            this.fillFieldMembers(dataSource.data, this.indexMatrix);
            this.updateSortSettings(dataSource.sortSettings, this.enableSort);
            this.valueMatrix = this.generateValueMatrix(dataSource.data);
            this.filterMembers = [];
            var pageSize = 1;
            this.updateFilterMembers(dataSource);
            this.rMembers = rows.length !== 0 ?
                this.getIndexedHeaders(rows, data, 0, rows[0].showNoDataItems ?
                    filterMembers : this.filterMembers, 'row', '') : this.rMembers;
            this.cMembers = columns.length !== 0 ?
                this.getIndexedHeaders(columns, data, 0, columns[0].showNoDataItems ?
                    filterMembers : this.filterMembers, 'column', '') : this.cMembers;
            this.insertAllMembersCommon();
            this.updateFieldList(savedFieldList);
            this.rowCount = 0;
            this.columnCount = 0;
            this.rMembers = this.updateFramedHeaders(this.rMembers, this.rMembers, rowFilteredData, this.filterFramedHeaders, 'row');
            this.filterFramedHeaders = [];
            this.cMembers = this.updateFramedHeaders(this.cMembers, this.cMembers, columnFilteredData, this.filterFramedHeaders, 'column');
            this.isValueFilterEnabled = true;
        }
        this.applyValueSorting();
        if (this.pageSettings) {
            if (!headerCollection || this.enableValueSorting) {
                this.headerCollection.rowHeaders = extend([], this.rMembers, null, true);
                this.headerCollection.columnHeaders = extend([], this.cMembers, null, true);
                this.headerCollection.rowHeadersCount = this.rowCount;
                this.headerCollection.columnHeadersCount = this.columnCount;
            }
            else {
                this.rMembers = headerCollection.rowHeaders;
                this.cMembers = headerCollection.columnHeaders;
                this.rowCount = headerCollection.rowHeadersCount;
                this.columnCount = headerCollection.columnHeadersCount;
                if (this.columns.length > 1 || this.rows.length > 1 || this.allowValueFilter) {
                    this.headerCollection = extend({}, headerCollection, null, true);
                }
            }
            this.calculatePagingValues();
            if (!this.enableValueSorting || !this.allowValueFilter) {
                if (rows.length > 0) {
                    this.insertPosition(rows, data, 0, this.filterMembers, 'row', '', this.rMembers);
                }
                if (columns.length > 0) {
                    this.insertPosition(columns, data, 0, this.filterMembers, 'column', '', this.cMembers);
                }
                this.rMembers = this.insertTotalPosition(this.rMembers);
                this.cMembers = this.insertTotalPosition(this.cMembers);
            }
        }
        this.getAggregatedHeaders(rows, columns, this.rMembers, this.cMembers, values);
        this.getHeaderData(this.cMembers, colheads, this.pivotValues, 0, this.valueAxis ? 1 : valuesCount);
        if (this.removeCount !== 0 && this.values.length > 0) {
            this.columnCount = this.columnCount - (this.removeCount * (this.valueAxis === 0 ? this.values.length : 1));
        }
        if ((!this.showGrandTotals || !this.showColumnGrandTotals) && this.columns.length > 0) {
            this.columnCount = this.columnCount - (1 * (this.valueAxis === 0 ? this.values.length : 1));
        }
        this.insertSubTotals();
        //this.getHeaderData(rmembers, rowheads, gridData, 0);              
        /* tslint:disable-next-line:max-line-length */
        this.getTableData(this.rMembers, rowheads, colheads, 0, this.pivotValues, valuesCount, this.rMembers[this.rMembers.length - 1], this.cMembers[this.cMembers.length - 1]);
        this.applyAdvancedAggregate(rowheads, colheads, this.pivotValues);
        if (this.pageSettings) {
            this.removeIndexProperties();
        }
        this.isEngineUpdated = true;
        var st2 = new Date().getTime();
        //  console.log(st1 - st2);
    };
    /* tslint:enable */
    PivotEngine.prototype.applyValueSorting = function () {
        if (this.valueSortSettings.headerText && this.valueSortSettings.headerText !== '' && this.values.length > 0) {
            var textArray = this.valueSortSettings.headerText.split(this.valueSortSettings.headerDelimiter);
            var hText = '';
            var mIndex = void 0;
            var mType = void 0;
            var caption = void 0;
            for (var i = 0; i < this.values.length; i++) {
                if (this.values[i].caption === textArray[textArray.length - 1]) {
                    caption = this.values[i].name;
                    break;
                }
                else {
                    caption = textArray[textArray.length - 1];
                }
            }
            if (this.values.length > 1 && caption && this.fieldList[caption]) {
                for (var i = 0; i < textArray.length - 1; i++) {
                    hText = hText === '' ? textArray[i] : (hText + this.valueSortSettings.headerDelimiter + textArray[i]);
                }
                mIndex = this.fieldList[caption].index;
                mType = this.fieldList[caption].aggregateType;
            }
            else {
                hText = this.valueSortSettings.headerText;
                mIndex = this.fieldList[this.values[0].name].index;
                mType = this.fieldList[this.values[0].name].aggregateType;
            }
            var member = void 0;
            if (this.valueAxis === 0) {
                member = this.getMember(this.cMembers, hText);
                if (member) {
                    this.sortByValueRow(this.rMembers, member, this.valueSortSettings.sortOrder, mIndex, mType);
                }
            }
            else {
                member = this.getMember(this.rMembers, hText);
                if (member) {
                    this.sortByValueRow(this.cMembers, member, this.valueSortSettings.sortOrder, mIndex, mType);
                }
            }
        }
    };
    PivotEngine.prototype.getMember = function (cMembers, headerText) {
        var vlen = cMembers.length;
        var member;
        for (var j = 0; j < vlen; j++) {
            if (cMembers[j].valueSort.levelName === headerText) {
                member = cMembers[j];
                break;
            }
            else if (cMembers[j].members.length > 0) {
                member = this.getMember(cMembers[j].members, headerText);
            }
            if (member) {
                return member;
            }
        }
        return member;
    };
    PivotEngine.prototype.sortByValueRow = function (rMembers, member, sortOrder, mIndex, mType) {
        var sort = false;
        var vlen = rMembers.length;
        for (var j = 0; j < vlen; j++) {
            for (var k = j; k < vlen && rMembers[j].type !== 'grand sum' && rMembers[k].type !== 'grand sum'; k++) {
                if (sortOrder === 'Descending') {
                    sort = this.getAggregateValue(rMembers[j].index, member.indexObject, mIndex, mType) <
                        this.getAggregateValue(rMembers[k].index, member.indexObject, mIndex, mType);
                }
                else {
                    sort = this.getAggregateValue(rMembers[j].index, member.indexObject, mIndex, mType) >
                        this.getAggregateValue(rMembers[k].index, member.indexObject, mIndex, mType);
                }
                if (sort) {
                    var temp = {};
                    temp = rMembers[j];
                    rMembers[j] = rMembers[k];
                    rMembers[k] = temp;
                }
            }
            if (rMembers[j].members.length > 0) {
                this.sortByValueRow(rMembers[j].members, member, sortOrder, mIndex, mType);
            }
        }
    };
    PivotEngine.prototype.insertAllMembersCommon = function () {
        /* inserting the row grant-total members */
        var rowFlag = (this.showGrandTotals && this.showRowGrandTotals) ? true : (this.rows.length > 0) ? false : true;
        if (rowFlag) {
            this.insertAllMember(this.rMembers, this.filterMembers, '', 'row');
        }
        /* inserting the column gran-total members */
        var columnFlag = (this.showGrandTotals && this.showColumnGrandTotals) ? true : (this.columns.length > 0) ? false : true;
        if (columnFlag) {
            this.insertAllMember(this.cMembers, this.filterMembers, '', 'column');
        }
    };
    PivotEngine.prototype.removeIndexProperties = function () {
        for (var rCnt = 0; rCnt < this.headerContent.length; rCnt++) {
            if (this.headerContent[rCnt]) {
                for (var cCnt = 0; cCnt < Object.keys(this.headerContent[rCnt]).length; cCnt++) {
                    var key = Number(Object.keys(this.headerContent[rCnt])[cCnt]);
                    this.headerContent[rCnt][key].index = [];
                    this.headerContent[rCnt][key].indexObject = {};
                    this.pivotValues[rCnt][key].index = [];
                    this.pivotValues[rCnt][key].indexObject = {};
                }
            }
        }
        for (var rCnt = this.headerContent.length; rCnt < this.pivotValues.length; rCnt++) {
            if (this.headerContent[rCnt]) {
                this.valueContent[rCnt - this.headerContent.length][0].index = [];
                this.valueContent[rCnt - this.headerContent.length][0].indexObject = {};
                this.pivotValues[rCnt][0].index = [];
                this.pivotValues[rCnt][0].indexObject = {};
            }
        }
    };
    PivotEngine.prototype.insertSubTotals = function () {
        var rowLength = this.pivotValues.length;
        for (var rowCnt = 0; rowCnt < rowLength; rowCnt++) {
            var rowCells = this.pivotValues[rowCnt];
            if (rowCells) {
                var savedCell = void 0;
                var spanCnt = 1;
                var colLength = rowCells.length;
                var indexObj = void 0;
                for (var colCnt = colLength - 1; colCnt > 0; colCnt--) {
                    var cell = rowCells[colCnt];
                    if (cell) {
                        if (savedCell) {
                            savedCell.colSpan = spanCnt;
                            savedCell.colIndex = savedCell.colIndex - (spanCnt - 1);
                        }
                        indexObj = { index: cell.index, indexObject: cell.indexObject };
                        cell.index = [];
                        cell.indexObject = {};
                        savedCell = extend({}, cell, null, true);
                        cell.index = indexObj.index;
                        cell.indexObject = indexObj.indexObject;
                        var rowPos = rowCnt + 1;
                        while (this.pivotValues[rowPos] && !this.pivotValues[rowPos][colCnt]) {
                            if (!this.pivotValues[rowCnt][colCnt].isDrilled) {
                                this.pivotValues[rowCnt][colCnt].rowSpan = (rowPos - rowCnt) + 1;
                                savedCell.rowSpan = (rowPos - rowCnt) + 1;
                            }
                            var cellType = (cell.type === 'sum' || cell.type === 'grand sum') ? cell.type : 'sum';
                            this.pivotValues[rowPos][colCnt] = this.headerContent[rowPos][colCnt] = {
                                type: cellType, formattedText: ((cell.type === 'sum' || cell.type === 'grand sum') ? cell.formattedText :
                                    (cell.formattedText + ' Total')),
                                axis: 'column', level: -1, colIndex: colCnt, rowIndex: rowPos, valueSort: cell.valueSort
                            };
                            if (cell.valueSort && cell.valueSort[this.valueSortSettings.headerText]) {
                                this.valueSortSettings.columnIndex = colCnt;
                            }
                            var isSpanned = false;
                            if (cellType === 'grand sum') {
                                this.pivotValues[rowCnt][colCnt].rowSpan = (rowPos - rowCnt) + 1;
                                savedCell.rowSpan = (rowPos - rowCnt) + 1;
                            }
                            else if (this.pivotValues[rowCnt][colCnt].type !== 'sum' &&
                                this.pivotValues[rowCnt][colCnt].isDrilled) {
                                this.pivotValues[rowCnt + 1][colCnt].rowSpan = rowPos - rowCnt;
                                isSpanned = true;
                            }
                            else {
                                this.pivotValues[rowPos][colCnt].rowSpan = -1;
                            }
                            if (rowPos > (rowCnt + 1) && (this.pivotValues[rowCnt][colCnt].type === 'sum' ||
                                isSpanned)) {
                                this.pivotValues[rowPos][colCnt].rowSpan = -1;
                            }
                            rowPos++;
                        }
                        spanCnt = 1;
                    }
                    else {
                        rowCells[colCnt] = this.headerContent[rowCnt][colCnt] = extend({}, savedCell, null, true);
                        rowCells[colCnt].index = this.headerContent[rowCnt][colCnt].index = indexObj.index;
                        rowCells[colCnt].indexObject = this.headerContent[rowCnt][colCnt].indexObject = indexObj.indexObject;
                        spanCnt++;
                        rowCells[colCnt].colSpan = spanCnt;
                        rowCells[colCnt].colIndex = rowCells[colCnt].colIndex - (spanCnt - 1);
                    }
                    if (colCnt === 1 && savedCell) {
                        savedCell.colSpan = spanCnt;
                        savedCell.colIndex = savedCell.colIndex - (spanCnt - 1);
                    }
                }
            }
        }
    };
    /* tslint:disable:max-func-body-length */
    PivotEngine.prototype.getIndexedHeaders = function (keys, data, keyInd, position, axis, parentMember) {
        var hierarchy = [];
        var showPosition = this.enableValueSorting || this.allowValueFilter || !this.pageSettings;
        if (keys) {
            var rlen = keys.length;
            var decisionObj = {};
            var fieldName = keys[keyInd].name;
            var field = keys[keyInd];
            // let members: string[] = Object.keys(this.fieldList[field].members);
            var childrens = this.fieldList[fieldName];
            var index = {};
            var isNoData = false;
            var isDateType = (this.formatFields[fieldName] &&
                (['date', 'dateTime', 'time'].indexOf(this.formatFields[fieldName].type) > -1));
            var showNoDataItems = (position.length < 1 && keyInd > 0) || field.showNoDataItems;
            var savedMembers = {};
            if (showNoDataItems) {
                var members = Object.keys(childrens.members);
                for (var pos = 0, lt = members.length; pos < lt; pos++) {
                    savedMembers[members[pos]] = members[pos];
                }
                if (position.length < 1) {
                    isNoData = true;
                    position.length = members.length;
                }
            }
            for (var pos = 0, lt = position.length; pos < lt; pos++) {
                var member = {};
                if (!isNullOrUndefined(keys[keyInd].showSubTotals) && !keys[keyInd].showSubTotals) {
                    member.showSubTotals = false;
                }
                member.hasChild = keyInd < rlen - 1;
                member.level = keyInd;
                member.axis = axis;
                member.colSpan = 1;
                var memInd = isNoData ? childrens.members[Object.keys(savedMembers)[0]].ordinal :
                    this.indexMatrix[position[pos]][childrens.index];
                var headerValue = isNoData ? Object.keys(savedMembers)[0] :
                    data[position[pos]][fieldName];
                if (isNullOrUndefined(headerValue)) {
                    continue;
                }
                delete savedMembers[headerValue];
                if (showNoDataItems && this.fieldFilterMem[fieldName] &&
                    this.fieldFilterMem[fieldName].memberObj[headerValue] === headerValue) {
                    continue;
                }
                member.isDrilled = member.hasChild ? childrens.members[headerValue].isDrilled : false;
                var formattedValue = isDateType ?
                    this.getFormattedValue(headerValue, fieldName) : { formattedText: headerValue.toString(), actualText: headerValue };
                member.actualText = formattedValue.actualText;
                member.formattedText = formattedValue.formattedText;
                if (isDateType) {
                    member.dateText = formattedValue.dateText;
                }
                var availData = showNoDataItems ? (this.filterPosObj[position[pos]] !== undefined &&
                    !isNoData ? true : false) : true;
                //member.name = members[memInd];
                // member.type = member.hasChild ? 'All' : 'Single';
                var pindx = void 0;
                if (!(decisionObj && decisionObj[memInd])) {
                    decisionObj[memInd] = { index: [], indexObject: {} };
                    member.index = decisionObj[memInd].index;
                    member.indexObject = decisionObj[memInd].indexObject;
                    if (availData) {
                        if (showPosition) {
                            member.index = decisionObj[memInd].index = [position[pos]];
                            decisionObj[memInd].indexObject[position[pos]] = position[pos];
                            member.indexObject = decisionObj[memInd].indexObject;
                        }
                        else {
                            index[memInd] = [position[pos]];
                        }
                    }
                    member.ordinal = memInd;
                    member.valueSort = {};
                    if (showPosition) {
                        member.valueSort.axis = fieldName;
                        if (keyInd !== 0) {
                            member.valueSort.levelName = parentMember + this.valueSortSettings.headerDelimiter + member.formattedText;
                            member.valueSort[parentMember + this.valueSortSettings.headerDelimiter + member.formattedText] = 1;
                        }
                        else {
                            member.valueSort[member.formattedText] = 1;
                            member.valueSort.levelName = member.formattedText;
                        }
                    }
                    //if (!member.members) {
                    member.members = [];
                    //}
                    //let copyObj: AxisSet = Object.create(member);
                    hierarchy.push(member);
                }
                else if (availData) {
                    if (showPosition) {
                        decisionObj[memInd].index.push(position[pos]);
                        decisionObj[memInd].indexObject[position[pos]] = position[pos];
                    }
                    else {
                        if (index[memInd] === undefined) {
                            index[memInd] = [position[pos]];
                        }
                        else {
                            index[memInd].push(position[pos]);
                        }
                    }
                }
                if (showNoDataItems && !isNoData && keyInd > 0 && pos + 1 === position.length &&
                    Object.keys(savedMembers).length > 0) {
                    isNoData = true;
                    lt = Object.keys(savedMembers).length;
                    pos = -1;
                }
            }
            for (var iln = 0, ilt = hierarchy.length; iln < ilt; iln++) {
                if (axis === 'row') {
                    this.rowCount += this.rowValuesLength;
                }
                else {
                    this.columnCount += this.colValuesLength;
                }
                if (rlen - 1 > keyInd && hierarchy[iln].isDrilled) {
                    if (showPosition) {
                        var level = null;
                        if (hierarchy[iln].valueSort && hierarchy[iln].valueSort.levelName) {
                            level = hierarchy[iln].valueSort.levelName;
                        }
                        parentMember = (level || hierarchy[iln].formattedText);
                    }
                    var filterPosition = !showPosition ? index[hierarchy[iln].ordinal] : hierarchy[iln].index;
                    /* tslint:disable:align */
                    hierarchy[iln].members = this.getIndexedHeaders(keys, data, keyInd + 1, (filterPosition === undefined ? [] : filterPosition), axis, parentMember);
                    /* tslint:enable:align */
                }
            }
            /* tslint:disable:typedef */
            if (this.enableSort) {
                // return new DataManager(hierarchy as JSON[]).executeLocal(new Query().sortBy('actualText', childrens.sort.toLowerCase()));
                if (isDateType) {
                    return childrens.sort === 'Ascending' ?
                        (hierarchy.sort(function (a, b) { return (a.dateText > b.dateText) ? 1 : ((b.dateText > a.dateText) ? -1 : 0); })) :
                        (hierarchy.sort(function (a, b) { return (a.dateText < b.dateText) ? 1 : ((b.dateText < a.dateText) ? -1 : 0); }));
                }
                else {
                    return childrens.sort === 'Ascending' ?
                        (hierarchy.sort(function (a, b) { return (a.actualText > b.actualText) ? 1 : ((b.actualText > a.actualText) ? -1 : 0); })) :
                        (hierarchy.sort(function (a, b) { return (a.actualText < b.actualText) ? 1 : ((b.actualText < a.actualText) ? -1 : 0); }));
                }
            }
            else {
                return hierarchy;
            }
            /* tslint:enable:typedef */
        }
        else {
            return hierarchy;
        }
    };
    PivotEngine.prototype.getOrderedIndex = function (headers) {
        var orderedIndex = {};
        for (var i = 0; i < headers.length; i++) {
            if (headers[i].type !== 'grand sum') {
                orderedIndex[headers[i].ordinal] = i;
            }
        }
        return orderedIndex;
    };
    PivotEngine.prototype.insertPosition = function (keys, data, keyInd, position, axis, parentMember, slicedHeaders) {
        var hierarchy = [];
        var orderedIndex = this.getOrderedIndex(slicedHeaders);
        if (keys) {
            var decisionObj = {};
            var field = keys[keyInd].name;
            var childrens = this.fieldList[field];
            for (var pos = 0, lt = position.length; pos < lt; pos++) {
                var member = {};
                var memInd = this.indexMatrix[position[pos]][childrens.index];
                var slicedHeader = slicedHeaders[orderedIndex[memInd]];
                var formattedValue = (this.formatFields[field] &&
                    (['date', 'dateTime', 'time'].indexOf(this.formatFields[field].type) > -1)) ?
                    this.getFormattedValue(data[position[pos]][field], field) :
                    { formattedText: data[position[pos]][field].toString(), actualText: data[position[pos]][field].toString() };
                if (!(slicedHeader && slicedHeader.formattedText === formattedValue.formattedText)) {
                    continue;
                }
                if (!(decisionObj && decisionObj[memInd])) {
                    decisionObj[memInd] = { index: [], indexObject: {} };
                    slicedHeader.index = decisionObj[memInd].index = [position[pos]];
                    decisionObj[memInd].indexObject[position[pos]] = position[pos];
                    slicedHeader.indexObject = decisionObj[memInd].indexObject;
                    slicedHeader.valueSort = {};
                    slicedHeader.valueSort.axis = field;
                    if (keyInd !== 0) {
                        slicedHeader.valueSort.levelName = parentMember + this.valueSortSettings.headerDelimiter +
                            slicedHeader.formattedText;
                        slicedHeader.valueSort[parentMember + this.valueSortSettings.headerDelimiter +
                            slicedHeader.formattedText] = 1;
                    }
                    else {
                        slicedHeader.valueSort[slicedHeader.formattedText] = 1;
                        slicedHeader.valueSort.levelName = slicedHeader.formattedText;
                    }
                    member.members = [];
                    hierarchy.push(member);
                }
                else {
                    decisionObj[memInd].index.push(position[pos]);
                    decisionObj[memInd].indexObject[position[pos]] = position[pos];
                }
            }
            var diff = slicedHeaders.length - hierarchy.length;
            while (diff > 0) {
                hierarchy.push({ members: [] });
                diff--;
            }
            for (var iln = 0, ilt = hierarchy.length; iln < ilt; iln++) {
                if (slicedHeaders[iln].members.length > 0) {
                    var level = null;
                    if (slicedHeaders[iln].valueSort && slicedHeaders[iln].valueSort.levelName) {
                        level = slicedHeaders[iln].valueSort.levelName;
                    }
                    parentMember = (level || slicedHeaders[iln].formattedText);
                    /* tslint:disable:align */
                    hierarchy[iln].members =
                        this.insertPosition(keys, data, keyInd + 1, slicedHeaders[iln].index, axis, parentMember, slicedHeaders[iln].members);
                    /* tslint:enable:align */
                }
            }
            return hierarchy;
        }
        else {
            return hierarchy;
        }
    };
    PivotEngine.prototype.insertTotalPosition = function (headers) {
        var summCell = headers[headers.length - 1];
        if (summCell && summCell.type === 'grand sum') {
            summCell.index = this.filterMembers;
            /* tslint:disable:typedef */
            var lt = void 0;
            for (var ln = 0, lt_1 = this.filterMembers.length; ln < lt_1; ln++) {
                summCell.indexObject[this.filterMembers[ln]] = this.filterMembers[ln];
            }
            /* tslint:enable:typedef */
        }
        return headers;
    };
    PivotEngine.prototype.calculatePagingValues = function () {
        var isValueSorting = ((this.valueSortSettings.sortOrder !== 'None' &&
            this.valueSortSettings.headerText !== '') || this.enableValueSorting) ? true : false;
        if (this.pageSettings) {
            if (this.valueAxis === 1) {
                this.rowValuesLength = this.values.length;
            }
            else {
                this.colValuesLength = this.values.length;
            }
            this.memberCnt = -this.rowValuesLength;
            this.rowStartPos = ((this.pageSettings.rowCurrentPage * this.pageSettings.rowSize) -
                (this.pageSettings.rowSize)) * this.rowValuesLength;
            var exactStartPos = (this.rowStartPos + (this.pageSettings.rowSize * 3 * this.rowValuesLength)) > this.rowCount ?
                (this.rowCount - (this.pageSettings.rowSize * 3 * this.rowValuesLength)) : this.rowStartPos;
            if (exactStartPos < 0) {
                exactStartPos = this.rowStartPos = 0;
                this.pageSettings.rowCurrentPage = 1;
            }
            this.rowFirstLvl = (this.rowStartPos - exactStartPos) % this.pageSettings.rowSize;
            this.rowStartPos = exactStartPos;
            this.endPos = this.rowStartPos + (this.pageSettings.rowSize * 3 * this.rowValuesLength);
            this.endPos = this.endPos > this.rowCount ? this.rowCount : this.endPos;
            this.rMembers = isValueSorting ? this.rMembers : this.performSlicing(this.rMembers, [], this.rowStartPos, 'row');
            this.memberCnt = -this.colValuesLength;
            this.pageInLimit = false;
            this.colHdrBufferCalculated = false;
            this.colStartPos = ((this.pageSettings.columnCurrentPage * this.pageSettings.columnSize) -
                (this.pageSettings.columnSize)) * this.colValuesLength;
            exactStartPos = (this.colStartPos + (this.pageSettings.columnSize * 3 * this.colValuesLength)) >
                this.columnCount ?
                (this.columnCount - (this.pageSettings.columnSize * 3 * this.colValuesLength)) : this.colStartPos;
            if (exactStartPos < 0) {
                exactStartPos = this.colStartPos = 0;
                this.pageSettings.columnCurrentPage = 1;
            }
            this.colFirstLvl = (this.colStartPos - exactStartPos) % this.pageSettings.columnSize;
            this.colStartPos = exactStartPos;
            if (!isValueSorting) {
                this.endPos = this.colStartPos + (this.pageSettings.columnSize * 3 * this.colValuesLength);
                this.endPos = this.endPos > this.columnCount ? this.columnCount : this.endPos;
                this.cMembers = this.performSlicing(this.cMembers, [], this.colStartPos, 'column');
            }
            this.memberCnt = -1;
            this.pageInLimit = false;
        }
    };
    PivotEngine.prototype.performSlicing = function (headers, slicedHeaders, startPos, axis) {
        var pos = 0;
        while (headers[pos]) {
            this.memberCnt += axis === 'column' ? this.colValuesLength : this.rowValuesLength;
            if (startPos <= this.memberCnt && this.endPos >= this.memberCnt && !this.pageInLimit) {
                if (axis === 'column') {
                    this.colFirstLvl = this.colFirstLvl + headers[pos].level;
                }
                else {
                    this.rowFirstLvl = this.rowFirstLvl + headers[pos].level;
                }
                this.pageInLimit = true;
            }
            if (this.pageInLimit) {
                if (this.endPos <= this.memberCnt) {
                    if (axis === 'column') {
                        if (headers[pos].members.length === 0) {
                            if (this.colHdrBufferCalculated) {
                                break;
                            }
                            this.colHdrBufferCalculated = true;
                            this.endPos += (headers[pos].level * this.colValuesLength);
                        }
                        else if (this.colHdrBufferCalculated) {
                            break;
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            var members = headers[pos].members;
            slicedHeaders.push(headers[pos]);
            if (headers[pos].members.length > 0) {
                slicedHeaders[slicedHeaders.length - 1].members = [];
                slicedHeaders[slicedHeaders.length - 1].members =
                    this.performSlicing(members, [], startPos, axis);
            }
            if (!this.pageInLimit) {
                slicedHeaders.pop();
            }
            if (headers[pos].level === 0 && this.pageInLimit && this.endPos <= this.memberCnt) {
                break;
            }
            pos++;
        }
        return slicedHeaders;
    };
    PivotEngine.prototype.insertAllMember = function (set, filter, customText, axis) {
        var len = set.length;
        var showPosition = this.enableValueSorting || this.allowValueFilter || !this.pageSettings;
        customText = ' Total';
        set[len] = {
            hasChild: false,
            index: !showPosition ? [] : filter,
            level: 0,
            axis: axis,
            isDrilled: false,
            indexObject: {},
            members: [],
            formattedText: 'Grand' + customText,
            ordinal: len,
            type: 'grand sum',
            valueSort: {}
        };
        set[len].valueSort[set[len].formattedText] = 1;
        set[len].valueSort.levelName = set[len].formattedText;
        if (showPosition) {
            for (var ln = 0, lt = filter.length; ln < lt; ln++) {
                set[len].indexObject[filter[ln]] = filter[ln];
            }
        }
        if (axis === 'row') {
            this.rowCount += this.rowValuesLength;
        }
        else {
            this.columnCount += this.colValuesLength;
        }
    };
    /* tslint:disable-next-line:max-line-length */
    PivotEngine.prototype.getTableData = function (rows, reformAxis, columns, tnum, data, vlt, rTotal, cTotal) {
        for (var rlt = rows.length, rln = 0; rln < rlt; rln++) {
            tnum = data.length;
            reformAxis[tnum] = rows[rln];
            var actCnt = tnum - Number(Object.keys(reformAxis)[0]);
            //let rplus: number = rln + 1;
            //let lvl: number = rows[rln].level;
            var isLeastNode = !reformAxis[tnum].members.length;
            rows[rln].colIndex = 0;
            rows[rln].rowIndex = tnum;
            if (!data[tnum]) {
                data[tnum] = [];
                this.valueContent[actCnt] = {};
                //data[tnum][0] = rows[rln].name;
                data[tnum][0] = this.valueContent[actCnt][0] = rows[rln];
            }
            else {
                // data[tnum][0] = rows[rln].name;
                data[tnum][0] = this.valueContent[actCnt][0] = rows[rln];
            }
            if (this.valueAxis && this.isMutiMeasures && !(rows[rln].isDrilled &&
                ((!isNullOrUndefined(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||
                    !this.showSubTotals || !this.showRowSubTotals))) {
                var hpos = tnum;
                var actpos = actCnt;
                for (var vln = 0; vln < vlt; vln++) {
                    tnum++;
                    actCnt++;
                    var name_1 = this.values[vln].caption ? this.values[vln].caption : this.values[vln].name;
                    var calObj = {
                        axis: 'row',
                        actualText: this.values[vln].name,
                        formattedText: name_1,
                        level: 0,
                        valueSort: {},
                        colIndex: 0,
                        rowIndex: tnum,
                        type: 'value'
                    };
                    if (!data[tnum]) {
                        data[tnum] = [];
                        this.valueContent[actCnt] = {};
                        data[tnum][0] = this.valueContent[actCnt][0] = calObj;
                    }
                    var vData = data[tnum][0].valueSort;
                    vData[data[tnum - vln - 1][0].valueSort.levelName + this.valueSortSettings.headerDelimiter + name_1] = 1;
                    vData.levelName = data[tnum - vln - 1][0].valueSort.levelName + this.valueSortSettings.headerDelimiter
                        + name_1;
                    for (var cln = 0, dln = 1, clt = columns.length; cln < clt; ++cln) {
                        //for (let vln: number = 0; (!this.valueAxis && vln < vlt); vln++) {
                        this.updateRowData(rows, columns, tnum, data, vln, rln, cln, dln, actCnt, rTotal, cTotal);
                        dln = data[tnum].length;
                        data[hpos][dln - 1] = this.valueContent[actpos][dln - 1] = {
                            axis: 'value', actualText: '', colSpan: 1,
                            colIndex: dln, formattedText: '', hasChild: false
                        };
                        // }
                    }
                }
                this.recursiveRowData(rows, reformAxis, columns, tnum, data, vlt, isLeastNode, rln, vlt, rTotal, cTotal);
            }
            else {
                for (var cln = 0, dln = 1, clt = columns.length; cln < clt; ++cln) {
                    for (var vln = 0; vln < vlt; vln++) {
                        this.updateRowData(rows, columns, tnum, data, vln, rln, cln, dln, actCnt, rTotal, cTotal);
                        dln = data[tnum].length;
                    }
                }
                this.recursiveRowData(rows, reformAxis, columns, tnum, data, vlt, isLeastNode, rln, 0, rTotal, cTotal);
            }
        }
        /* for (let rlt: number = rows.length, rln: number = 0; rln < rlt; rln++) {
            if (!data[rln]) {
                data[rln] = [];
                data[rln][0] = rows[rln].name;
            } else {
                data[rln][0] = rows[rln].name;
            }
            for (let cln: number = 0, dln: number = 1, clt: number = columns.length; cln < clt; dln = ++cln) {
                data[rln][dln] = this.getAggregateValue(rows[rln].index, columns[cln].index, 11);
            }
        } */
    };
    /* tslint:disable-next-line:max-line-length */
    PivotEngine.prototype.getAggregatedHeaders = function (rows, columns, rMembers, cMembers, values) {
        this.selectedHeaders = { selectedHeader: [], values: [] };
        for (var vlt = values.length, vln = 0; vln < vlt; vln++) {
            switch (values[vln].type) {
                case 'DifferenceFrom':
                case 'PercentageOfDifferenceFrom':
                    {
                        var baseField = void 0;
                        var baseItem = void 0;
                        this.selectedHeaders.values.push(values[vln].name);
                        if (values[vln].baseField && values[vln].baseItem) {
                            baseField = values[vln].baseField;
                            baseItem = values[vln].baseItem;
                        }
                        else if (this.valueAxis && this.isMutiMeasures && columns.length > 0) {
                            baseField = columns[0].name;
                            baseItem = Object.keys(this.fieldList[columns[0].name].members)[0];
                        }
                        else if (rows.length > 0) {
                            baseField = rows[0].name;
                            baseItem = Object.keys(this.fieldList[rows[0].name].members)[0];
                        }
                        var isHeaderSelected = false;
                        for (var _i = 0, rows_2 = rows; _i < rows_2.length; _i++) {
                            var row = rows_2[_i];
                            if (row.name === baseField) {
                                /* tslint:disable-next-line:max-line-length */
                                this.getAggregatedHeaderData(rMembers, values[vln].name, baseItem, false, 'row', values[vln].type, this.selectedHeaders.selectedHeader, vln);
                                isHeaderSelected = true;
                                break;
                            }
                        }
                        if (!isHeaderSelected) {
                            for (var _a = 0, columns_1 = columns; _a < columns_1.length; _a++) {
                                var column = columns_1[_a];
                                if (column.name === baseField) {
                                    /* tslint:disable-next-line:max-line-length */
                                    this.getAggregatedHeaderData(cMembers, values[vln].name, baseItem, false, 'column', values[vln].type, this.selectedHeaders.selectedHeader, vln);
                                    break;
                                }
                            }
                        }
                    }
                    break;
                case 'PercentageOfParentRowTotal':
                case 'PercentageOfParentColumnTotal':
                    {
                        this.selectedHeaders.values.push(values[vln].name);
                        /* tslint:disable-next-line:max-line-length */
                        this.getAggregatedHeaderData((values[vln].type === 'PercentageOfParentRowTotal' ? rMembers : cMembers), values[vln].name, undefined, false, (values[vln].type === 'PercentageOfParentRowTotal' ? 'row' : 'column'), values[vln].type, this.selectedHeaders.selectedHeader, vln);
                    }
                    break;
                case 'RunningTotals':
                    {
                        this.selectedHeaders.values.push(values[vln].name);
                        /* tslint:disable-next-line:max-line-length */
                        this.getAggregatedHeaderData((this.valueAxis && this.isMutiMeasures ? cMembers : rMembers), values[vln].name, undefined, false, (this.valueAxis && this.isMutiMeasures ? 'column' : 'row'), values[vln].type, this.selectedHeaders.selectedHeader, vln);
                    }
                    break;
                case 'PercentageOfParentTotal':
                    {
                        var baseField = void 0;
                        this.selectedHeaders.values.push(values[vln].name);
                        if (values[vln].baseField) {
                            baseField = values[vln].baseField;
                        }
                        else if (this.valueAxis && this.isMutiMeasures && columns.length > 0) {
                            baseField = columns[0].name;
                        }
                        else if (rows.length > 0) {
                            baseField = rows[0].name;
                        }
                        var isHeaderSelected = false;
                        for (var len = rows.length, i = 0; i < len; i++) {
                            if (rows[i].name === baseField) {
                                /* tslint:disable-next-line:max-line-length */
                                this.getAggregatedHeaderData(rMembers, values[vln].name, undefined, false, 'row', values[vln].type, this.selectedHeaders.selectedHeader, vln, i);
                                isHeaderSelected = true;
                                break;
                            }
                        }
                        if (!isHeaderSelected) {
                            for (var len = columns.length, i = 0; i < len; i++) {
                                if (columns[i].name === baseField) {
                                    /* tslint:disable-next-line:max-line-length */
                                    this.getAggregatedHeaderData(cMembers, values[vln].name, undefined, false, 'column', values[vln].type, this.selectedHeaders.selectedHeader, vln, i);
                                    break;
                                }
                            }
                        }
                    }
                    break;
            }
        }
    };
    /* tslint:disable-next-line:max-line-length */
    PivotEngine.prototype.getAggregatedHeaderData = function (headers, name, baseItem, isChildren, type, aggregateType, selectedHeaders, vln, level) {
        for (var _i = 0, headers_1 = headers; _i < headers_1.length; _i++) {
            var rln = headers_1[_i];
            switch (aggregateType) {
                case 'DifferenceFrom':
                case 'PercentageOfDifferenceFrom':
                    {
                        var levelName = rln.valueSort.levelName.toString().split('.');
                        if (levelName.indexOf(baseItem) !== -1) {
                            /* tslint:disable-next-line:max-line-length */
                            selectedHeaders.push(this.updateSelectedHeaders(baseItem, rln.level, type, isChildren, name, aggregateType, rln.valueSort.levelName, (isChildren ? [rln] : headers), vln + 1));
                            if (rln.members.length > 0) {
                                /* tslint:disable-next-line:max-line-length */
                                this.getAggregatedHeaderData(rln.members, name, baseItem, true, type, aggregateType, selectedHeaders[selectedHeaders.length - 1].childMembers, vln);
                            }
                        }
                        else if (rln.members.length > 0) {
                            this.getAggregatedHeaderData(rln.members, name, baseItem, false, type, aggregateType, selectedHeaders, vln);
                        }
                    }
                    break;
                case 'RunningTotals':
                case 'PercentageOfParentRowTotal':
                case 'PercentageOfParentColumnTotal':
                    {
                        if (rln.type === 'grand sum') {
                            /* tslint:disable-next-line:max-line-length */
                            selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, headers, vln + 1));
                        }
                        else {
                            if (rln.members.length > 0) {
                                /* tslint:disable-next-line:max-line-length */
                                selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, rln.members, vln + 1));
                                /* tslint:disable-next-line:max-line-length */
                                this.getAggregatedHeaderData(rln.members, name, undefined, false, type, aggregateType, selectedHeaders, vln);
                            }
                        }
                    }
                    break;
                case 'PercentageOfParentTotal':
                    {
                        if (rln.type !== 'grand sum') {
                            if (rln.level === level) {
                                if (rln.members.length > 0) {
                                    if (isChildren) {
                                        var aggregateHeaders = selectedHeaders[selectedHeaders.length - 1].aggregateHeaders;
                                        for (var _a = 0, _b = rln.members; _a < _b.length; _a++) {
                                            var member = _b[_a];
                                            aggregateHeaders.push(member);
                                        }
                                    }
                                    else {
                                        var children = extend([], rln.members, null, true);
                                        /* tslint:disable-next-line:max-line-length */
                                        selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, children, vln + 1));
                                        var aggregateHeaders = selectedHeaders[selectedHeaders.length - 1].aggregateHeaders;
                                        aggregateHeaders.push(rln);
                                    }
                                    /* tslint:disable-next-line:max-line-length */
                                    this.getAggregatedHeaderData(rln.members, name, undefined, true, type, aggregateType, selectedHeaders, vln, level + 1);
                                }
                                else {
                                    if (!isChildren) {
                                        /* tslint:disable-next-line:max-line-length */
                                        selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, [rln], vln + 1));
                                    }
                                }
                            }
                            else if (rln.members.length > 0) {
                                /* tslint:disable-next-line:max-line-length */
                                this.getAggregatedHeaderData(rln.members, name, undefined, false, type, aggregateType, selectedHeaders, vln, level);
                            }
                        }
                    }
                    break;
            }
        }
    };
    /* tslint:disable-next-line:max-line-length */
    PivotEngine.prototype.updateSelectedHeaders = function (baseItem, level, type, isChildren, name, aggregateType, levelName, headers, vCount) {
        var headerData = {
            name: baseItem,
            level: level,
            axis: type,
            isChild: isChildren,
            value: name,
            type: aggregateType,
            uniqueName: levelName,
            aggregateHeaders: headers,
            childMembers: [],
            valueCount: vCount
        };
        return headerData;
    };
    PivotEngine.prototype.applyAdvancedAggregate = function (rowheads, colheads, data) {
        if (this.selectedHeaders.values.length > 0) {
            var pivotIndex = {};
            var colIndex = [];
            var isIndexFilled = false;
            for (var rlt = data.length, rln = 0; rln < rlt; rln++) {
                if (data[rln] !== undefined && data[rln][0] !== undefined) {
                    if (!isIndexFilled) {
                        for (var clt = data[rln].length, cln = 0; cln < clt; cln++) {
                            if (data[rln][cln].axis === 'value' &&
                                this.selectedHeaders.values.indexOf(data[rln][cln].actualText) !== -1) {
                                colIndex.push(cln);
                                isIndexFilled = true;
                            }
                        }
                    }
                    if (colIndex.length > 0 && data[rln][colIndex[0]].axis === 'value' &&
                        this.selectedHeaders.values.indexOf(data[rln][colIndex[0]].actualText) !== -1) {
                        for (var _i = 0, colIndex_1 = colIndex; _i < colIndex_1.length; _i++) {
                            var index = colIndex_1[_i];
                            pivotIndex[rln + ',' + index] = [rln, index];
                        }
                    }
                }
            }
            this.updateAggregates(rowheads, colheads, data, this.selectedHeaders.selectedHeader, colIndex, pivotIndex);
            var indexCollection = Object.keys(pivotIndex);
            for (var _a = 0, indexCollection_1 = indexCollection; _a < indexCollection_1.length; _a++) {
                var index = indexCollection_1[_a];
                var currentSet = data[pivotIndex[index][0]][pivotIndex[index][1]];
                // currentSet.formattedText = '0';
                currentSet.formattedText = (this.selectedHeaders.selectedHeader.length > 0 ? '0' : '#N/A');
            }
        }
        else {
            return;
        }
    };
    /* tslint:disable:all */
    PivotEngine.prototype.updateAggregates = function (rowheads, colheads, data, selectedHeaders, colIndex, pivotIndex) {
        for (var _i = 0, selectedHeaders_1 = selectedHeaders; _i < selectedHeaders_1.length; _i++) {
            var headers = selectedHeaders_1[_i];
            var selectedHeaderCollection = headers.aggregateHeaders;
            var name_2 = headers.value;
            var valueCount = (this.valueAxis && this.isMutiMeasures ? headers.valueCount : 0);
            var aggregateType = headers.type;
            var uniqueName = headers.uniqueName;
            var axis = headers.axis;
            var isRowBaseField = axis === 'row' ? true : false;
            var activeValues = void 0;
            var indexCollection = [];
            var activeColumn = [];
            var columnHeaders = [];
            var rowindexCollection = [];
            var selectedRowValues = [];
            var selectedColumnValues = [];
            if ((['DifferenceFrom', 'PercentageOfDifferenceFrom', 'PercentageOfParentRowTotal', 'PercentageOfParentColumnTotal', 'PercentageOfParentTotal', 'RunningTotals']).indexOf(headers.type) !== -1) {
                if (isRowBaseField) {
                    if (headers.type !== 'RunningTotals') {
                        for (var rlt = rowheads.length, rln = 0; rln < rlt; rln++) {
                            if (rowheads[rln] !== undefined) {
                                if (rowheads[rln].valueSort[uniqueName]) {
                                    activeValues = rowheads[rln];
                                    selectedRowValues = data[rln + valueCount];
                                    break;
                                }
                            }
                        }
                    }
                }
                else {
                    for (var len_1 = data.length, i = 0; i < len_1; i++) {
                        if (data[i] !== undefined && data[i][0] === undefined) {
                            columnHeaders.push(data[i]);
                        }
                        else {
                            break;
                        }
                    }
                    var len = columnHeaders.length;
                    while (len--) {
                        var axisObj = columnHeaders[len][colIndex[0]];
                        var cLevelName = axisObj.actualText;
                        if (this.selectedHeaders.values.indexOf(cLevelName) === -1) {
                            activeColumn = columnHeaders[len];
                            len = 0;
                        }
                    }
                    if (headers.type !== 'RunningTotals') {
                        for (var clt = activeColumn.length, cln = 0; cln < clt; cln++) {
                            var isSelectedColumn = false;
                            if (activeColumn[cln] !== undefined && activeColumn[cln].valueSort[uniqueName]) {
                                activeValues = activeColumn[cln];
                                for (var len_2 = data.length, i = 0; i < len_2; i++) {
                                    var axisObj = data[i];
                                    if (axisObj !== undefined && axisObj[0] !== undefined &&
                                        axisObj[cln].axis === 'value' &&
                                        this.selectedHeaders.values.indexOf(axisObj[cln].actualText) !== -1) {
                                        isSelectedColumn = true;
                                        selectedColumnValues[i] = axisObj[cln];
                                        rowindexCollection.push(i);
                                    }
                                }
                                if (isSelectedColumn) {
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            switch (headers.type) {
                case 'DifferenceFrom':
                case 'PercentageOfDifferenceFrom':
                    {
                        var isChildren = headers.isChild;
                        if (isRowBaseField) {
                            if (!isChildren) {
                                for (var _a = 0, selectedHeaderCollection_1 = selectedHeaderCollection; _a < selectedHeaderCollection_1.length; _a++) {
                                    var item = selectedHeaderCollection_1[_a];
                                    for (var rlt = rowheads.length, rln = 0; rln < rlt; rln++) {
                                        if (rowheads[rln] !== undefined) {
                                            if (rowheads[rln].valueSort[item.valueSort.levelName] &&
                                                rowheads[rln].level === activeValues.level && rowheads[rln].type !== 'grand sum') {
                                                for (var _b = 0, colIndex_2 = colIndex; _b < colIndex_2.length; _b++) {
                                                    var index = colIndex_2[_b];
                                                    var currentSet = data[rln + valueCount][index];
                                                    if (currentSet.axis === 'value' && currentSet.actualText === name_2) {
                                                        indexCollection.push([rln + valueCount, index]);
                                                        if (pivotIndex[rln + valueCount + ',' + index]) {
                                                            delete pivotIndex[rln + valueCount + ',' + index];
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                var uniqueLevelName = uniqueName.split('.');
                                for (var rlt = rowheads.length, rlen = 0; rlen < rlt; rlen++) {
                                    if (rowheads[rlen] !== undefined) {
                                        var levelName = rowheads[rlen].valueSort.levelName.toString().split('.');
                                        if (levelName.indexOf(uniqueLevelName[uniqueLevelName.length - 1]) !== -1 &&
                                            rowheads[rlen].level === activeValues.level) {
                                            for (var _c = 0, colIndex_3 = colIndex; _c < colIndex_3.length; _c++) {
                                                var index = colIndex_3[_c];
                                                var currentSet = data[rlen + valueCount][index];
                                                if (currentSet.axis === 'value' && currentSet.actualText === name_2) {
                                                    indexCollection.push([rlen + valueCount, index]);
                                                    if (pivotIndex[rlen + valueCount + ',' + index]) {
                                                        delete pivotIndex[rlen + valueCount + ',' + index];
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            for (var _d = 0, indexCollection_2 = indexCollection; _d < indexCollection_2.length; _d++) {
                                var index = indexCollection_2[_d];
                                var currentSet = data[index[0]][index[1]];
                                var cVal = currentSet.value - selectedRowValues[index[1]].value;
                                cVal = isNaN(cVal) ? 0 : cVal;
                                if (aggregateType === 'DifferenceFrom') {
                                    currentSet.formattedText = this.getFormattedValue(cVal, name_2).formattedText;
                                }
                                else {
                                    cVal = (selectedRowValues[index[1]].value === 0 ?
                                        0 : (cVal / selectedRowValues[index[1]].value));
                                    currentSet.formattedText = (cVal !== 0 ? this.globalize.formatNumber(cVal, { format: 'P', maximumFractionDigits: 2 }) : '0');
                                }
                            }
                        }
                        else {
                            if (!isChildren) {
                                for (var _e = 0, selectedHeaderCollection_2 = selectedHeaderCollection; _e < selectedHeaderCollection_2.length; _e++) {
                                    var item = selectedHeaderCollection_2[_e];
                                    for (var clt = activeColumn.length, cln = 0; cln < clt; cln++) {
                                        var isSelectedColumn = false;
                                        if (activeColumn[cln] !== undefined &&
                                            activeColumn[cln].valueSort[item.valueSort.levelName] &&
                                            activeColumn[cln].level === activeValues.level && activeColumn[cln].type !== 'grand sum') {
                                            for (var _f = 0, rowindexCollection_1 = rowindexCollection; _f < rowindexCollection_1.length; _f++) {
                                                var index = rowindexCollection_1[_f];
                                                var currentSet = data[index][cln];
                                                if (currentSet.axis === 'value' && currentSet.actualText === name_2) {
                                                    isSelectedColumn = true;
                                                    indexCollection.push([index, cln]);
                                                    if (pivotIndex[index + ',' + cln]) {
                                                        delete pivotIndex[index + ',' + cln];
                                                    }
                                                }
                                            }
                                            if (isSelectedColumn) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                var uniqueLevelName = uniqueName.split('.');
                                for (var clt = activeColumn.length, clen = 0; clen < clt; clen++) {
                                    var isSelectedColumn = false;
                                    if (activeColumn[clen] !== undefined) {
                                        var levelName = activeColumn[clen].valueSort.levelName.toString().split('.');
                                        if (levelName.indexOf(uniqueLevelName[uniqueLevelName.length - 1]) !== -1 &&
                                            activeColumn[clen].level === activeValues.level) {
                                            for (var _g = 0, rowindexCollection_2 = rowindexCollection; _g < rowindexCollection_2.length; _g++) {
                                                var index = rowindexCollection_2[_g];
                                                var currentSet = data[index][clen];
                                                if (currentSet.axis === 'value' && currentSet.actualText === name_2) {
                                                    isSelectedColumn = true;
                                                    indexCollection.push([index, clen]);
                                                    if (pivotIndex[index + ',' + clen]) {
                                                        delete pivotIndex[index + ',' + clen];
                                                    }
                                                }
                                            }
                                            if (isSelectedColumn) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            for (var _h = 0, indexCollection_3 = indexCollection; _h < indexCollection_3.length; _h++) {
                                var index = indexCollection_3[_h];
                                var currentSet = data[index[0]][index[1]];
                                var cVal = currentSet.value - selectedColumnValues[index[0]].value;
                                cVal = isNaN(cVal) ? 0 : cVal;
                                if (aggregateType === 'DifferenceFrom') {
                                    currentSet.formattedText = this.getFormattedValue(cVal, name_2).formattedText;
                                }
                                else {
                                    cVal = (selectedColumnValues[index[0]].value === 0 ?
                                        0 : (cVal / selectedColumnValues[index[0]].value));
                                    currentSet.formattedText = (cVal !== 0 ? this.globalize.formatNumber(cVal, { format: 'P', maximumFractionDigits: 2 }) : '0');
                                }
                            }
                        }
                        if (headers.childMembers.length > 0) {
                            this.updateAggregates(rowheads, colheads, data, headers.childMembers, colIndex, pivotIndex);
                        }
                    }
                    break;
                case 'PercentageOfParentRowTotal':
                case 'PercentageOfParentColumnTotal':
                case 'PercentageOfParentTotal':
                    {
                        if (isRowBaseField) {
                            for (var _j = 0, selectedHeaderCollection_3 = selectedHeaderCollection; _j < selectedHeaderCollection_3.length; _j++) {
                                var item = selectedHeaderCollection_3[_j];
                                for (var rlt = rowheads.length, i = 0; i < rlt; i++) {
                                    if (rowheads[i] !== undefined) {
                                        if (rowheads[i].valueSort[item.valueSort.levelName] &&
                                            rowheads[i].level === item.level) {
                                            for (var _k = 0, colIndex_4 = colIndex; _k < colIndex_4.length; _k++) {
                                                var index = colIndex_4[_k];
                                                var currentSet = data[i + valueCount][index];
                                                if (currentSet.axis === 'value' && currentSet.actualText === name_2) {
                                                    indexCollection.push([i + valueCount, index]);
                                                    if (pivotIndex[i + valueCount + ',' + index]) {
                                                        delete pivotIndex[i + valueCount + ',' + index];
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            for (var _l = 0, indexCollection_4 = indexCollection; _l < indexCollection_4.length; _l++) {
                                var i = indexCollection_4[_l];
                                var currentSet = data[i[0]][i[1]];
                                var cVal = currentSet.value / selectedRowValues[i[1]].value;
                                cVal = isNaN(cVal) ? 0 : cVal;
                                currentSet.formattedText = (cVal !== 0 ? this.globalize.formatNumber(cVal, { format: 'P', maximumFractionDigits: 2 }) : '0');
                            }
                        }
                        else {
                            for (var _m = 0, selectedHeaderCollection_4 = selectedHeaderCollection; _m < selectedHeaderCollection_4.length; _m++) {
                                var item = selectedHeaderCollection_4[_m];
                                for (var clt = activeColumn.length, j = 0; j < clt; j++) {
                                    var isSelectedColumn = false;
                                    if (activeColumn[j] !== undefined &&
                                        activeColumn[j].valueSort[item.valueSort.levelName]) {
                                        for (var _o = 0, rowindexCollection_3 = rowindexCollection; _o < rowindexCollection_3.length; _o++) {
                                            var index = rowindexCollection_3[_o];
                                            var currentSet = data[index][j];
                                            if (currentSet.axis === 'value' && currentSet.actualText === name_2) {
                                                isSelectedColumn = true;
                                                indexCollection.push([index, j]);
                                                if (pivotIndex[index + ',' + j]) {
                                                    delete pivotIndex[index + ',' + j];
                                                }
                                            }
                                        }
                                        if (isSelectedColumn) {
                                            break;
                                        }
                                    }
                                }
                            }
                            for (var _p = 0, indexCollection_5 = indexCollection; _p < indexCollection_5.length; _p++) {
                                var i = indexCollection_5[_p];
                                var currentSet = data[i[0]][i[1]];
                                var val = currentSet.value / selectedColumnValues[i[0]].value;
                                val = isNaN(val) ? 0 : val;
                                currentSet.formattedText = (val !== 0 ? this.globalize.formatNumber(val, { format: 'P', maximumFractionDigits: 2 }) : '0');
                            }
                        }
                    }
                    break;
                case 'RunningTotals':
                    {
                        if (isRowBaseField) {
                            for (var _q = 0, colIndex_5 = colIndex; _q < colIndex_5.length; _q++) {
                                var index = colIndex_5[_q];
                                var cVal = 0;
                                for (var _r = 0, selectedHeaderCollection_5 = selectedHeaderCollection; _r < selectedHeaderCollection_5.length; _r++) {
                                    var item = selectedHeaderCollection_5[_r];
                                    for (var rlt = rowheads.length, rlen = 0; rlen < rlt; rlen++) {
                                        if (rowheads[rlen] !== undefined) {
                                            var currentSet = data[rlen + valueCount][index];
                                            if (rowheads[rlen] !== undefined && rowheads[rlen].valueSort[item.valueSort.levelName] &&
                                                rowheads[rlen].level === item.level && currentSet.axis === 'value' &&
                                                currentSet.actualText === name_2) {
                                                if (rowheads[rlen].type !== 'grand sum') {
                                                    cVal += currentSet.value;
                                                    currentSet.formattedText = this.getFormattedValue(cVal, name_2).formattedText;
                                                }
                                                if (pivotIndex[rlen + valueCount + ',' + index]) {
                                                    delete pivotIndex[rlen + valueCount + ',' + index];
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            for (var rlt = rowheads.length, rln = 0; rln < rlt; rln++) {
                                if (rowheads[rln] !== undefined) {
                                    var cVal = 0;
                                    for (var _s = 0, selectedHeaderCollection_6 = selectedHeaderCollection; _s < selectedHeaderCollection_6.length; _s++) {
                                        var item = selectedHeaderCollection_6[_s];
                                        for (var clt = activeColumn.length, cln = 0; cln < clt; cln++) {
                                            var currentSet = data[rln + valueCount][cln];
                                            if (activeColumn[cln] !== undefined &&
                                                activeColumn[cln].valueSort[item.valueSort.levelName] &&
                                                currentSet.axis === 'value' && currentSet.actualText === name_2) {
                                                if (activeColumn[cln].type !== 'grand sum') {
                                                    cVal += currentSet.value;
                                                    currentSet.formattedText = this.getFormattedValue(cVal, name_2).formattedText;
                                                }
                                                if (pivotIndex[rln + valueCount + ',' + cln]) {
                                                    delete pivotIndex[rln + valueCount + ',' + cln];
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    break;
            }
        }
    };
    /* tslint:enable:all */
    PivotEngine.prototype.recursiveRowData = function (rows, reformAxis, columns, tnum, data, vlt, isLeastNode, rln, vln, rTotal, cTotal) {
        if (!isLeastNode) {
            this.getTableData(reformAxis[tnum - vln].members, reformAxis, columns, tnum, data, vlt, rTotal, cTotal);
        }
        reformAxis[tnum - vln].members = [];
    };
    PivotEngine.prototype.updateRowData = function (rows, columns, tnum, data, vln, rln, cln, dln, actCnt, rTotal, cTotal) {
        var mPos = this.fieldList[this.values[vln].name].index;
        var aggregate = this.fieldList[this.values[vln].name].aggregateType;
        var field = this.values[vln].name;
        var gTotalIndex = [];
        var totalValues = {};
        var value = 0;
        // let isLeast: boolean = isLeastNode && (vln === vlt - 1);
        switch (aggregate) {
            case 'Index':
                {
                    gTotalIndex = [[rows[rln], columns[cln]], [rows[rln], cTotal], [rTotal, columns[cln]], [rTotal, cTotal]];
                    var valueContent = ['cVal', 'rTotalVal', 'cTotalVal', 'gTotalVal'];
                    var i = 0;
                    for (var _i = 0, gTotalIndex_1 = gTotalIndex; _i < gTotalIndex_1.length; _i++) {
                        var rIndex = gTotalIndex_1[_i];
                        totalValues[valueContent[i]] = this.getAggregateValue((rIndex[0]).index, (rIndex[1]).indexObject, mPos, aggregate);
                        i++;
                    }
                    var val = ((totalValues.cVal) * (totalValues.gTotalVal)) / ((totalValues.rTotalVal) * (totalValues.cTotalVal));
                    value = (rows[rln].isDrilled && ((!isNullOrUndefined(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||
                        !this.showSubTotals || !this.showRowSubTotals)) ? undefined :
                        (isNaN(val) ? 0 : val);
                }
                break;
            case 'PercentageOfGrandTotal':
            case 'PercentageOfColumnTotal':
            case 'PercentageOfRowTotal':
                {
                    gTotalIndex = [[rows[rln], columns[cln]]];
                    gTotalIndex.push((aggregate === 'PercentageOfGrandTotal' ?
                        [rTotal, cTotal] : (aggregate === 'PercentageOfColumnTotal' ? [rTotal, columns[cln]] : [rows[rln], cTotal])));
                    var valueContent = ['cVal', 'gTotalVal'];
                    var i = 0;
                    for (var _a = 0, gTotalIndex_2 = gTotalIndex; _a < gTotalIndex_2.length; _a++) {
                        var rIndex = gTotalIndex_2[_a];
                        totalValues[valueContent[i]] = this.getAggregateValue((rIndex[0]).index, (rIndex[1]).indexObject, mPos, aggregate);
                        i++;
                    }
                    var val = ((totalValues.cVal) / (totalValues.gTotalVal));
                    value = (rows[rln].isDrilled && ((!isNullOrUndefined(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||
                        !this.showSubTotals || !this.showRowSubTotals)) ? undefined :
                        (isNaN(val) ? 0 : val);
                }
                break;
            default:
                value = (rows[rln].isDrilled && ((!isNullOrUndefined(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||
                    !this.showSubTotals || !this.showRowSubTotals)) ? undefined :
                    this.getAggregateValue(rows[rln].index, columns[cln].indexObject, mPos, aggregate);
                break;
        }
        var isSum = rows[rln].hasChild || columns[cln].hasChild ||
            rows[rln].type === 'grand sum' || columns[cln].type === 'grand sum';
        var subTotal = (rows[rln].isDrilled && ((!isNullOrUndefined(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||
            !this.showSubTotals || !this.showRowSubTotals));
        var formattedText = subTotal ?
            '' : aggregate === 'Count' ? value.toLocaleString() : this.getFormattedValue(value, field).formattedText;
        if (value && (['PercentageOfGrandTotal', 'PercentageOfColumnTotal', 'PercentageOfRowTotal']).indexOf(aggregate) >= 0) {
            formattedText = this.globalize.formatNumber(value, { format: 'P', maximumFractionDigits: 2 });
        }
        else if (!subTotal &&
            isNaN(value) && (['PopulationStDev', 'SampleStDev', 'PopulationVar', 'SampleVar']).indexOf(aggregate) !== -1) {
            formattedText = '#DIV/0!';
        }
        //dln = data[tnum].length;
        data[tnum][dln] = this.valueContent[actCnt][dln] = {
            axis: 'value', actualText: field, indexObject: this.isDrillThrough ? this.rawIndexObject : {},
            rowHeaders: rows[rln].type === 'grand sum' ? '' : rows[rln].valueSort.levelName,
            columnHeaders: columns[cln].type === 'grand sum' ? '' : columns[cln].valueSort.levelName,
            formattedText: formattedText, value: value, rowIndex: tnum, colIndex: dln, isSum: isSum
        };
        this.rawIndexObject = {};
    };
    PivotEngine.prototype.getHeaderData = function (axis, reformAxis, data, tnum, vcnt) {
        var rlt = axis.length;
        var colItmLn = this.columns.length;
        var sortText = this.valueSortSettings.headerText;
        //let valueLn: number = this.values.length;
        for (var rln = 0; rln < rlt; rln++) {
            if (axis[rln].members.length) {
                this.getHeaderData(axis[rln].members, reformAxis, data, tnum, vcnt);
            }
            if ((!isNullOrUndefined(axis[rln].showSubTotals) && !axis[rln].showSubTotals) ||
                !this.showSubTotals || !this.showColumnSubTotals) {
                if (!axis[rln].isDrilled) {
                    reformAxis[reformAxis.length] = axis[rln];
                }
                else {
                    this.removeCount++;
                }
                tnum = reformAxis.length - 1;
            }
            else {
                tnum = reformAxis.length;
                reformAxis[tnum] = axis[rln];
            }
            //  let rplus: number = rln + 1;
            var lvl = axis[rln].level;
            axis[rln].rowIndex = lvl;
            axis[rln].colIndex = (tnum * vcnt) + vcnt;
            if (!data[lvl]) {
                data[lvl] = [];
                this.headerContent[lvl] = {};
                data[lvl][(tnum * vcnt) + vcnt] = this.headerContent[lvl][(tnum * vcnt) + vcnt] = axis[rln];
            }
            else {
                data[lvl][(tnum * vcnt) + vcnt] = this.headerContent[lvl][(tnum * vcnt) + vcnt] = axis[rln];
            }
            if (this.isMutiMeasures && !this.valueAxis) {
                for (var vln = 0; vln < vcnt; vln++) {
                    var name_3 = this.values[vln].caption ? this.values[vln].caption : this.values[vln].name;
                    var calObj = {
                        axis: 'column',
                        actualText: this.values[vln].name,
                        formattedText: name_3,
                        level: 0,
                        valueSort: {},
                        colIndex: (tnum * vcnt) + 1 + vln,
                        rowIndex: colItmLn
                    };
                    if (!data[colItmLn]) {
                        data[colItmLn] = [];
                        this.headerContent[colItmLn] = {};
                        data[colItmLn][(tnum * vcnt) + 1 + vln] = this.headerContent[colItmLn][(tnum * vcnt) + 1 + vln] = calObj;
                    }
                    else {
                        data[colItmLn][(tnum * vcnt) + 1 + vln] = this.headerContent[colItmLn][(tnum * vcnt) + 1 + vln] = calObj;
                    }
                    var vData = data[colItmLn][(tnum * vcnt) + 1 + vln].valueSort;
                    vData[axis[rln].valueSort.levelName + this.valueSortSettings.headerDelimiter + name_3] = 1;
                    vData.levelName = axis[rln].valueSort.levelName + this.valueSortSettings.headerDelimiter + name_3;
                    if (vData && vData[sortText]) {
                        this.valueSortSettings.columnIndex = (tnum * vcnt) + 1 + vln;
                    }
                }
            }
            else if (axis[rln].valueSort && axis[rln].valueSort[sortText]) {
                this.valueSortSettings.columnIndex = (tnum * vcnt) + 1;
            }
            reformAxis[tnum].members = [];
        }
    };
    /* tslint:disable */
    PivotEngine.prototype.getAggregateValue = function (rowIndex, columnIndex, value, type) {
        //rowIndex = rowIndex.sort();
        //columnIndex = columnIndex.sort();
        var rlt = rowIndex.length;
        //let clt: number = columnIndex.length;
        var mirror = {};
        var ri = 0;
        var ci = 0;
        var cellValue = 0;
        var avgCnt = 0;
        var isInit = true;
        if (type && type.toLowerCase() === 'count') {
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined) {
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    cellValue += (this.valueMatrix[rowIndex[ri]][value] === undefined ? 0 : 1);
                }
                ri++;
            }
        }
        else if (type && type.toLowerCase() === 'distinctcount') {
            var duplicateValues = [];
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined) {
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    var currentVal = this.valueMatrix[rowIndex[ri]][value];
                    if (currentVal !== undefined) {
                        if (duplicateValues.length === 0 || (duplicateValues.length > 0 && duplicateValues.indexOf(currentVal) === -1)) {
                            cellValue += 1;
                            duplicateValues.push(currentVal);
                        }
                    }
                }
                ri++;
            }
        }
        else if (type && type.toLowerCase() === 'product') {
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined) {
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    var currentVal = this.valueMatrix[rowIndex[ri]][value];
                    if (currentVal !== undefined) {
                        cellValue = (isInit ? 1 : (cellValue === 0 ? 1 : cellValue));
                        cellValue *= currentVal;
                    }
                    isInit = false;
                }
                ri++;
            }
        }
        else if (type && (['populationstdev', 'samplestdev', 'populationvar', 'samplevar']).indexOf(type.toLowerCase()) !== -1) {
            var i = 0;
            var val = 0;
            var indexVal = [];
            var avgVal = 0;
            var cVal = 0;
            var avgDifferenceVal = 0;
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined) {
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    var currentVal = this.valueMatrix[rowIndex[ri]][value];
                    if (currentVal !== undefined) {
                        val += currentVal;
                        indexVal.push(currentVal);
                        i++;
                    }
                }
                ri++;
            }
            if (i > 0) {
                avgVal = val / i;
                for (var _i = 0, indexVal_1 = indexVal; _i < indexVal_1.length; _i++) {
                    var index = indexVal_1[_i];
                    avgDifferenceVal += Math.pow((index - avgVal), 2);
                }
                if ((['populationstdev', 'samplestdev']).indexOf(type.toLowerCase()) !== -1) {
                    cVal = Math.sqrt(avgDifferenceVal / (type.toLowerCase() === 'populationstdev' ? i : (i - 1)));
                }
                else {
                    cVal = avgDifferenceVal / (type.toLowerCase() === 'populationvar' ? i : (i - 1));
                }
                cellValue = (cVal === 0 ? NaN : cVal);
            }
            else {
                cellValue = val;
            }
        }
        else if (type && type.toLowerCase() === 'min') {
            var isFirst = true;
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined) {
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    if (isFirst) {
                        cellValue = this.valueMatrix[rowIndex[ri]][value];
                        isFirst = false;
                    }
                    else {
                        cellValue = this.valueMatrix[rowIndex[ri]][value] < cellValue ? this.valueMatrix[rowIndex[ri]][value] : cellValue;
                    }
                }
                ri++;
            }
        }
        else if (type && type.toLowerCase() === 'max') {
            var isMaxFirst = true;
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined) {
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    if (isMaxFirst) {
                        cellValue = this.valueMatrix[rowIndex[ri]][value];
                        isMaxFirst = false;
                    }
                    else {
                        cellValue = this.valueMatrix[rowIndex[ri]][value] > cellValue ? this.valueMatrix[rowIndex[ri]][value] : cellValue;
                    }
                }
                ri++;
            }
        }
        else if (type && type.toLowerCase() === 'calculatedfield') {
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined) {
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    var calcField = this.calculatedFields[this.fields[value]];
                    var actualFormula = calcField.formula;
                    var aggregateField = {};
                    if (this.calculatedFormulas[calcField.name]) {
                        var calculatedFormulas = this.calculatedFormulas[calcField.name];
                        for (var len = 0, lmt = calculatedFormulas.length; len < lmt; len++) {
                            var aggregatedValue = calculatedFormulas[len];
                            var value_1 = aggregateField[aggregatedValue.formula];
                            if (value_1 === undefined) {
                                var type_1 = aggregatedValue.type;
                                value_1 = this.getAggregateValue(rowIndex, columnIndex, aggregatedValue.index, type_1);
                                aggregateField[aggregatedValue.formula] = value_1;
                            }
                            actualFormula = (actualFormula).replace(aggregatedValue.formula, value_1.toString());
                        }
                    }
                    // /* tslint:disable */
                    cellValue = eval(actualFormula);
                    // /* tslint:enable */
                    JSON.parse(cellValue.toString());
                }
                ri++;
            }
        }
        else {
            while (rowIndex[ri] !== undefined) {
                if (columnIndex[rowIndex[ri]] !== undefined) {
                    this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                    //let cIndx: number = isLeastLevel ? columnIndex.splice(columnIndex.indexOf(rowIndex[ri]), 1)[0] : rowIndex[ri];
                    var currentVal = this.valueMatrix[rowIndex[ri]][value];
                    cellValue += (currentVal === undefined ? 0 : currentVal);
                    avgCnt++;
                }
                ri++;
            }
        }
        /* if (rlt > clt) {
             this.makeMirrorObject(rowIndex, mirror);
             while (columnIndex[ci] !== undefined) {
                 if (mirror[columnIndex[ci]]) {
                     let cIndx: number = isLeastLevel ? columnIndex.splice(ci, 1)[0] : columnIndex[ci];
                     //rowIndex.splice
                     sum += this.valueMatrix[cIndx][value];
                 }
                 ci++;
             }
         } else {
             this.makeMirrorObject(columnIndex, mirror);
             while (rowIndex[ri] !== undefined) {
                 if (mirror[rowIndex[ri]]) {
                     let cIndx: number = isLeastLevel ? columnIndex.splice(columnIndex.indexOf(rowIndex[ri]), 1)[0] : rowIndex[ri];
                     sum += this.valueMatrix[rowIndex[ri]][value];
                 }
                 ri++;
             }
         } */
        return ((type && type.toLowerCase() === 'avg' && cellValue !== 0) ? (cellValue / avgCnt) : cellValue);
    };
    /* tslint:enable */
    /** hidden */
    PivotEngine.prototype.getFormattedValue = function (value, fieldName) {
        var formattedValue = {
            formattedText: value !== undefined ? value === null ? 'null' : value.toString() : undefined,
            actualText: value !== undefined ? value === null ? 'null' : value : undefined,
            dateText: value !== undefined ? value === null ? 'null' : value : undefined
        };
        if (this.formatFields[fieldName] && value) {
            var formatField = (this.formatFields[fieldName].properties ?
                this.formatFields[fieldName].properties : this.formatFields[fieldName]);
            var formatSetting = extend({}, formatField, null, true);
            delete formatSetting.name;
            if (!formatSetting.minimumSignificantDigits && formatSetting.minimumSignificantDigits < 1) {
                delete formatSetting.minimumSignificantDigits;
            }
            if (!formatSetting.maximumSignificantDigits && formatSetting.maximumSignificantDigits < 1) {
                delete formatSetting.maximumSignificantDigits;
            }
            if (formatSetting.type) {
                formattedValue.formattedText = this.globalize.formatDate(new Date(value), formatSetting);
            }
            else {
                formattedValue.formattedText = this.globalize.formatNumber(value, formatSetting);
            }
            formattedValue.actualText = value;
            if (formatSetting.type && ['date', 'dateTime', 'time'].indexOf(this.formatFields[fieldName].type) > -1) {
                formatSetting.format = 'yyyy/MM/dd/HH/mm/ss';
                formattedValue.dateText = this.globalize.formatDate(new Date(value), formatSetting);
            }
        }
        return formattedValue;
    };
    PivotEngine.prototype.powerFunction = function (formula) {
        if (formula.indexOf('^') > -1) {
            var items_1 = [];
            while (formula.indexOf('(') > -1) {
                formula = formula.replace(/(\([^\(\)]*\))/g, function (text, item) {
                    items_1.push(item);
                    return ('~' + (items_1.length - 1));
                });
            }
            items_1.push(formula);
            formula = '~' + (items_1.length - 1);
            while (formula.indexOf('~') > -1) {
                formula = formula.replace(new RegExp('~' + '(\\d+)', 'g'), function (text, index) {
                    return items_1[index].replace(/(\w*)\^(\w*)/g, 'Math.pow' + '($1,$2)');
                });
            }
        }
        return formula;
    };
    return PivotEngine;
}());
export { PivotEngine };
